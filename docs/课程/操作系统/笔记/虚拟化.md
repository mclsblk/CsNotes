### 什么是虚拟化
#### 共享 CPU
- 通过**虚拟化** CPU、内存等硬件，让一个进程只运行一个时间片（**分时共享**），然后切换到其他进程，操作系统提供了一个假象，使得较多的进程可以运行在有限的资源上
- 进程的组成（机器状态）：
	- 内存（地址空间）：指令+数据
	- 寄存器：程序计数器，栈指针等
#### 共享内存
- 地址空间：运行的程序看到的系统中的内存
- 操作系统通过虚拟内存，使得程序认为它被加载到特定地址的内存中，并且具有非常大的地址空间
- 虚拟内存系统的目标：
	- **透明**：操作系统实现虚拟内存的方式，应该让运行的程序看不见。（不应感知到内存被虚拟化）
	- 效率：时间&空间（不会更慢，不需要太多额外存储）
	- 保护：确保进程收到保护（不会受到其他进程的映像），操作系统本身更不应该受到进程的影响
### 操作系统的进程管理
- 操作系统初始化阶段加载了**第一个进程**
- 操作系统是状态机的管理者
- fork-exevce-exit 构成了 unix 中的进程世界
#### 进程的概念
- 进程由三部分组成：程序代码段、数据段、PCB（进程控制块）
- PCB：
	- 系统通过 PCB 了解进程的信息，在进程执行结束时回收 PCB
	- 主要包含了：进程描述信息（进程标识符、用户标识符等）、进程控制和管理信息（描述进程运行状态，作为 CPU 调度的依据）、资源分配信息、处理机相关信息（CPU 寄存器等上下文信息）

- 进程的状态：
	- 运行态：正在 CPU 上运行
	- 就绪态：获得了除了 CPU 以外的全部资源，得到 CPU 就可以开始运行了（这个时间通常很短  ）
	- 阻塞态：正在等待某一个事件而暂停（如 IO, 等待除了 CPU 之外的资源）
	- 创建态：正在被创建（步骤：创建 PCB，分配资源，转入就绪）
	- 终止态：正在消失，如运行结束，还需要进行资源释放回收等操作
- 进程的状态转换：
	- ![463e0d7ab0c39a28a579dd206f2a7a7.jpg|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/463e0d7ab0c39a28a579dd206f2a7a7.jpg)
- 

- 进程的管理方式
	- 连接方式：将相同状态的 PCB 连接成一个队列
	- 索引方式：将同一状态的进程组织在一个索引表
#### 进程的创建 -fork
- `pid_t fork(void);` 创建**当前线程的完整克隆**
	- 是对当前进程（状态机）的完整复制（内存、寄存器现场等）
	- 父进程会收到返回值为子进程的进程号
	- 子进程收到返回值 0
	- 返回值（RAX）就是两个线程的唯一区别
- ![image.png|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240422160834.png)

- 具体过程
	- 分配进程标识号，申请空白 PCB
	- 分配其他资源，如内存，IO 设备等
	- 初始化 PCB，信息
	- 插入就绪队列等待调度

```c
pid_t x = fork();
pid_t y = fork();
printf("%d %d\n", x, y);
```
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240422162713.png)

#### 执行可执行文件-execve
- `int execve(const char *filename,char * const argv[], char * const envp[]);`
	- “重置“状态机，将当前进程重置为一个可执行文件描述的状态机的初始状态（**一个可执行文件实际就描述了一个状态机的初始状态**）
- 将一个程序转化为进程，首先要将代码和静态数据从磁盘**加载**到内存中
	- ![image.png|300](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240619111815.png)
	- 通常惰性执行，再程序执行期间根据需求动态加载
- 操作系统还需要做其他**初始化操作**，如为程序栈、堆初始化并分配空间以及执行 IO 设置相关的工作
- 最后操作系统启动执行程序，转到入口处开始执行，将控制权转交给新创建的线程


- 应用程序的执行环境 `env`
	- `PATH`: 可执行文件搜索路径
	- `PWD`: 当前路径
	- `HOME`: home 目录
	- `DISPLAY`: 图形输出
	- `PS1`: shell 的提示符
```c
int main() {
    char *const argv[] = {
        "/bin/bash",
        "-c",
        "env",
        NULL,
    };

    char *const envp[] = {
        "HELLO=WORLD",
        NULL,
    };

    // Reset the state machine to "/bin/bash"
    execve(argv[0], argv, envp);

    // We are here only on error.
    printf("Hello, World!\n");
}

```

- fork+execve
	- 执行新程序的常见使用方式
	- fork 创建子进程，使用 execve 将子进程初始化为目标可执行文件对应的状态机
```c
int pid = fork();
if (pid == -1) {
    perror("fork"); goto fail;
} else if (pid == 0) {
    // Child
    execve(...);
    perror("execve"); goto fail;
} else {
    // Parent
    ...
}
```
#### 终止进程-\_exit
- **主动**销毁进程
- `void _exit(int status);`
	- 立即摧毁状态机，允许有一个返回值 (子进程会通知父进程)
	- 会终止进程中的所有线程
- C 语言提供的退出方式
	- return main 函数
	- exit (num)
	- 这两种否会调用 atexit，可以做一些退出之前的处理
- 操作系统提供的退出方式
	- `_exit(num)`
	- `syscall(SYS_exit,0)`
	- 会直接终止进程，buhu 8 i 调用 atexit

- 具体过程：
	- 根据标识符检索 PCB
	- 终止进程执行（如果在运行态）
	- 释放资源（归还给父进程或操作系统）
	- 将 PCB 从所在链表移除
```c
void func() {
    printf("Goodbye, Cruel OS World!\n");
}

int main(int argc, char *argv[]) {
    // This is a convenient mechanism for 
    atexit(func);
	//c语言提供的方式
    if (argc < 2) {
        return EXIT_FAILURE;
    }
    if (strcmp(argv[1], "exit") == 0) {
        exit(0);
    }
	//操作系统提供的方式
    if (strcmp(argv[1], "_exit") == 0) {
        _exit(0);
    }
    if (strcmp(argv[1], "__exit") == 0) {
        syscall(SYS_exit, 0);
    }
}
```
### CPU 调度
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240512223729.png)
	- 使用三级调度：
	- 高级调度（作业调度）：从外存处于后备队列的作业中选一个来载入内存、创建相关的进程
	- 中级调度（内存调度）：将暂时不能运行的进程调入外存（挂起）具备运行条件并且内存空闲时再调回。主要是为了提高内存的利用率
	- 低级调度（进程调度）：从就绪队列中选取进程，分配 CPU，进程调度的进行频率很高，最基本的调度
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240512223744.png)
	- 排队器：将系统中所有就绪进程按照一定策略排成一个或多个队列
	- 分配器：根据调度程序所选的进程，从队列中取出，并为其分配进程
	- 上下文切换器：保存就上下文、恢复新上下文

- 进程的调度方式
	- 非抢占式调度：只有一个进程运行完成或者进入阻塞态，才能将 CPU 分配给其他进程
	- 抢占式调度：更重要的进程需要使用 CPU 则允许调度程序暂停正在执行的进程，分配给紧急进程
- 两种线程调度
	- 用户级线程调度：内核只是选择一个进程执行，用户进程中的调度程序决定要调用的线程
	- 内核级线程调度：内核选择特定额线程执行

- 调度的目标
	- $CPU 利用率=\frac{{CPU有效工作时间}}{CPU有效工作时间+CPU空闲等待时间}$
	- 系统吞吐量：单位时间 CPU 完成的作业数量
	- 周转时间：作业提交到作业完成所经历的时间
		- $作业周转时间=作业完成时间-作业提交时间$
		- $带权周转时间=\frac{{作业周转时间}}{作业实际运行时间}$
	- 等待时间：进程处于等待 CPU 的时间之和
	- 响应时间：用户提交请求到首次产生响应的时间
	- ![|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/6e5748fbf402bb1eda78de5b3dcc85f.jpg)
#### 典型调度算法
![image.png](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240512233736.png)

- 先来先服务 FCFS
	- 即 FIFO
	- 长作业会占用太长时间，不适用于分时系统和实时系统，通常结合使用
- 短作业优先 SJF
	- 一般是非抢占式的，每次优先从队列中选择短作业执行
	- 对长作业不公平，可能被长期抢占（饥饿问题）
- 高响应比优先调度算法
	- 主要用于作业调度，考虑作业的等待时间和运行时间
	- $响应比=\frac{{等待时间+要求服务时间}}{要求服务时间}$
	- 等待时间相同时短作业的响应比更大优先调度，等待时间较长时长作业也有机会（克服了饥饿问题）
- 优先级调度
	- 根据优先级进行调度
	- 非抢占式：高优先级也要等当前进程执行完成
	- 抢占式：优先级更高的进入队列，则暂停当前正在执行的任务 (实时系统通常使用)
	- 静态优先级：预先设置（可能导致低优先级进程长期不能被执行）
	- 动态优先级：会随着等待时间而变化，如增加
	- 一般来说有：系统进程>用户进程；交互型进程>非交互型进程；IO 进程>计算进程
- 时间片轮转调度 RR
	- 主要用于分时系统
	- 执行完一个时间片后将当前进程移到末尾，重新取进程继续执行
- 多级队列调度算法
	- 设置不同就绪队列，对进程分类，使用不同的调度算法
- 多级反馈队列调度算法
	- 时间片轮转+优先级调度
	- ![6662809bd19bf0a3e82d8d4f8b15d73.jpg|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/6662809bd19bf0a3e82d8d4f8b15d73.jpg)
	- 设置多个就绪队列，优先级递减（分配的时间片指数递增）
	- 每个队列内部使用 FIFO 如果进程没有在时间片内执行完成，则移动到下一个队列
	- 只有优先级更高的队列为空，才能执行低优先级，并且为抢占式
### 进程间通信方式
- 共享内存：区别于线程，默认下进程的地址空间是相互隔离的，因此需要通过特殊的系统调用获取
- 消息队列：操作系统提供的消息接受和发送方式
- 管道通信：特殊的共享文件，先进先出, 按照生产者消费者模式进行通讯
### 进程地址空间
- 查看进程的地址空间及权限 `/proc/[pid]/maps
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240422175406.png)
	- 地址范围|权限|偏移量|设备|innode（对应文件）|路径名或标记
- 或者使用 `pmap` 命令查看管局进程的内存使用信息
#### \*vdso
- 一段运行在用户空间的代码，允许一些特定的系统调用（如获取时间）避免进行上下文切换到内核态，可以调高执行的效率（尤其是调用频繁的系统调用）
- vDSO 通过将一小段代码**映射到用户进程的地址空间**来工作。这段代码实现了一些系统调用的功能。当应用程序需要执行某些系统调用时，它可以直接调用这些已映射到用户空间的函数，而无需执行完整的系统调用过程。
#### 管理进程的地址空间
- 增加、删除、修改可访问的内存，进行内存申请等工作
- `mmap` 系统调用用于将设备或文件映射到内存中，从而**创建**一块可以直接通过指针访问的内存区域。
	- `void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);`
	- `addr`: 希望映射区域的首选起始地址。通常设为 NULL，由系统选择映射区域的地址。
	- `length`: 映射区域的长度。
	- `prot`: 映射区域的保护权限。可以是以下几个值的组合：
	    - `PROT_READ`: 可读。
	    - `PROT_WRITE`: 可写。
	    - `PROT_EXEC`: 可执行。
	    - `PROT_NONE`: 不可访问。
	- `flags`: 控制映射的行为。常见的标志包括：
	    - `MAP_FIXED`: 使用指定的`addr`精确地址；如果地址已被使用，会替换原有的映射。
	    - `MAP_SHARED`: 对映射的修改会反映到底层文件上，并且对其他所有映射同一文件的进程可见。
	    - `MAP_PRIVATE`: 对映射区域的写入不会写回到原文件，而是创建一个写时复制的私有副本。
	- `fd`: 要映射的文件的文件描述符。若是创建匿名映射，则设为-1。
	- `offset`: 文件中的偏移，映射从文件的这个偏移开始。
```c
volatile uint8_t *p = mmap(
        NULL,
        8 GiB,//宏定义的
        PROT_READ | PROT_WRITE,
        MAP_ANONYMOUS | MAP_PRIVATE,
        -1, 0
    );
```

- `munmap` 函数用于**取消**映射的内存区域，释放这部分区域。
	- `int munmap(void *addr, size_t length);`
	- `addr`: 映射区域的起始地址。
	- `length`: 映射区域的长度。

- `mprotect` 函数用于**修**改现有内存区域的保护权限。
	- `int mprotect(void *addr, size_t length, int prot);`
	- `addr`: 需要修改权限的内存区域的起始地址。
	- `length`: 需要修改权限的内存区域的长度。
	- `prot`: 新的保护权限，同 `mmap` 中的保护权限。
#### 入侵进程的地址空间
- 一个进程**对其他进程的地址**进行访问，就可以任意改变另一个程序的行为
- 如何查找变量的存储空间（金山游侠）
	- 让目标变量发生变化，查找发生了相同变化的内存，直至能唯一确定
	- 之后直接对内存的数据进行修改
- 给进程发送虚假信号（按键精灵）
	- 如发送 gui 事件（鼠标键盘）
- 改变进程对时间的感知（变速齿轮）
	- syscall：gettimeofday，sleep（用于等待时间）
	- 将 syscall 链接到自定义的方法（hook 函数的执行）
	- 应用：软件动态更新
### 内存管理
- 内存管理的主要内容：
	- 内存空间分配与回收
	- 地址转换
	- 内存地址的扩充
	- 内存共享
	- 存储保护

- 操作系统可以分配大段的内存（甚至超过物理上限 ）；由程序自己负责更细致的分配小段内存，如使用 `malloc()free()`，在操作系统提供的 `[L,R)` 范围内**维护互不相交的区间集合**

- 多级内存管理：第一级由操作系统分配，操作系统将内存交给进程，在进程结束时进行回收；第二级在进程中，由进程在内部进行管理。

- 在实际系统中，我们通常不考虑“最坏情况“（现实中的应用是 “正常” 的，不是 “恶意” 的） ，应该结合实际的 workload 来进行设计和优化
- 实际的情况
	- 小对象：字符串、临时对象等；生存周期**可长可短**
	- 中对象：容器、复杂的对象；更长的生存周期
	- 大对象：巨大的容器、分配器；**很长的生存周期**
- 因此管理的**重点是小对象**，小对象分配/回收的 scalability 是主要瓶颈（多 CPU 上同时进行）

- 思想：设置两套系统
	- first path：性能极好、并行度极高、覆盖大部分情况，但有小概率会失败
	- slow path：不在乎那么快，但把困难的事情做好
- 具体到 malloc
	- first path：给所有线程事先分配“领地”, 线程**默认从自己的领地分配**（线程**本地**完成），如果自己的领地不足再从全局借用：为了实现更好的性能浪费一点是可以接受的（比如内存对齐）
		- 针对不同大小的空间需求，使用不同的特定分配器（不同细粒度，像棋盘一样直接分配一个格子）
	- slow path：pgalloc ()
#### 内存分配
- 单一连续分配：
	- 将内存分为系统区和用户区
	- 分配方式很简单，不需要内存保护（内存中也只有一道程序），只适用于单用户单任务操作系统，有内部碎片存储器利用率较低
- 固定分区分配：
	- 最简单的多道程序存储管理方法，将**用户内存空间划分**为若干固定大小的分区，每个分区只装入一道作业
	- 有分区空闲时从外存的后备作业队列中选择适当大小的作业状图分区
	- 如果分区大小相等会造成较多浪费，通常划分为：多个较小区间、适量的中等分区和少量大分区
	- 使用**分区表**来进行分配和回收：表中记录分区号、大小和起始地址以及分配状态，分配内存时就对表进行检索并选择内存进行分配
	- 问题：分区大小固定不够灵活，利用可能不充分
- 以上两种为静态重定位不需要硬件地址变换机构，由装入程序或操作系统完成地址转换

- 动态分区分配：
	- 可变分区分配，根据实际需要动态的进行分配
	- 问题：随着时间推移，会产生大量的外部内存碎片，需要整理程序
- 动态分区分配内存的内存回收算法
	- 设置一个分区链表，分配内存时通过遍历节点寻找分区，较大时还可以对节点进行分割
	- 回收时在链中找到相应的位置插入，此外如果插入后发现与前后节点的空间连续，还可以对内存做**合并**操作
- 基于顺序搜索的分配算法（性能都不太好）
	- **首次适应算法**：空闲地址递增，分配时顺序查找第一个能满足大小的内存分区，使低地址出现了较多碎片（性能相对较好）
	- **邻近适应算法**：分配内存时从上次查找的结束位置开始
	- **最佳适应算法**：空闲分区按容递增分配，顺序查找第一个能满足大小的空间，性能较差产生了很多小碎片（产生最多的碎片）
	- **最坏适应算法**：容量递减排序，每次选择最大空闲分区分割空间
	- **当系统较大时，顺序遍历很慢**
- 基于索引搜索的分配算法 : 根据大小对碎片空间进行分类，分为不同的链
	- **快速适应算法**：根据进程常用大小进行划分，首先在索引表中找到最小能容纳的分区链表，然后从链表中取出第一块进行分配（会进行切割），但是也需要在回收时进行分区合并
	- **伙伴系统**：所有分区的大小均为 $2^k$，对于需要 $2^{i-1}<n<2^i$ 空间时从大小为 $2^i$ 的链表中进行寻找，如果没有则分裂 $2^{i+1}$ 的空闲分区。合并时也要对伙伴分区进行合并（从同一个块分裂来的）
	- **哈希算法**：根据空闲分区链表的分布规律建立哈希函数，构建以空闲分区大小为关键字的哈希表，表项为对应的头指针，每次通过哈希计算得到头指针从中得到空闲的分区链表

- 注意：固定分区产生的是内部碎片（分配的区域没有被完全利用）；动态分区产生的是外部碎片（切割产生的）
#### 虚拟内存管理
- 虚拟存储器就是系统好像为用户提供一个比实际内存大的多的存储器，称为虚拟存储器。
	- 特点：多次性（分次装入）；对换性（内存外存换出换入）；虚拟性（从逻辑上扩容了内存的容量）
- 分页主要的目的是提高内存利用率及计算机性能，通过操作系统和硬件机制实现，对用户完全透明
	- 分页长度固定，会产生内部碎片
- 分段管理考虑了用户和程序员：实现方便编程、信息保护和共享、动态增长和动态链接
	- 长度根据需要分配，会产生外部碎片
- 段页式存储中：每个进程有一个段表，每一个段对应一个（多级）页表
	- 即每个进程一个段表但是可能有多个页表

- 请求分页管理方式：以基本分页系统为基础（换入），还提供了请求调页和页面置换功能（换出）
	- 为了实现换入换出，添加字段：状态位（是否已经调入内存）；访问字段（被访问次数，用于置换）；修改位（是否被修改过）；
	- 缺页的处理：缺页中断（内部异常），由操作系统处理
	- ![f9be64d8be1c59cc5bb357b619a117a.jpg|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/f9be64d8be1c59cc5bb357b619a117a.jpg)

- 抖动：同一个页面被反复换入换出
	- 根本原因：分配的物理块太少
- 工作集：某段时间间隔内进程要访问的页面结合
##### 页框管理与页面置换
- 驻留集：给一个进程分配的页框的集合
	- 越小：单个进程占用的资源就越少，大事难事缺页率相对较高
	- 越大：存在边际效应，浪费内存空间
- 内存分配策略
	- **固定分配局部置换**：为每个进程分配**固定数目**的物理块，运行中发生缺页则只能从分配的内存中选择换出换入
		- 可以使用：平均分配；按进程大小比例分配；优先权分配
	- **可变分配全局置换**：先分配一定数目，但是在运行中根据运行工情况动态调整，发生缺页时从空闲队列分配，更加灵活。可能导致动态增加太多，进程占用太大。
	- **可变分配局部置换**：发生缺页时，只允许从进程自己的内存中换出，根据**缺页率**动态调整分配的块的数目
- 调入页面的时机：
	- 预调页策略：根据**局部性**原理一次调入若干相邻页面（打不死股成功率不高）
	- 请求调页策略：需要用时（不存在）才调入，调入的页面都一定会被使用

页面置换算法
- **最佳置换 OPT**
	- 换出以后永不使用的页面或**最长时间内不再使用的**（不过这是难以确定预测的），只向前看
- **先进先出 FIFO**
	- 淘汰最早进入内存的页面
	- 分配更多物理块可能反而导致缺页增加（belady 现象）
- **最近最久未使用 LRU**
	- 淘汰最近最长时间没有使用的页面，只向后看
- **时钟置换 CLOCK**（最近未用 NRU）
	- 当一个页面被装入或被访问时，其访问为置为 1，算法将内存中的页面连接成一个循环队列，有一个替换指针，选择淘汰一页时，如果值为 1，则修改为 0（**给一次机会**先不换出）；如果为 0 则换出，然后**指向下一个页面**。
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240513223812.png)
- **改进的 CLOCK 算法**
	- 修改过的页面换出时需要写回（也就是说会有更大的代价，因此综合考虑访问位 A 和修改位 M）
	- $A=0,M=0$ 最佳淘汰页
	- $A=0,M=1$ 次佳淘汰页
	- $A=1,M=0$ 可能再被访问
	- $A=1,M=1$ 可能再被访问
	- 先寻找最佳淘汰页（这遍不修改访问位）；第二轮扫描寻找次佳淘汰页，这次访问位置 0，直到找到为止
	- 改进版减少了磁盘 IO 操作

## 可执行文件和加载
### 可执行文件
- 可执行文件：一个操作系统中的对象 (文件)，描述了状态机初始状态的**数据结构**
#### 装载程序
- 绝对装入：只适用于单道程序环境，使用**绝对地址**（程序中的逻辑地址与存储的实际地址相同）
- 可重定位状装入（静态重定位）：在装入时一次性完成（必须直接分配足够的内存），运行中不能在内存中移动也不能申请内存空间
- 动态运行时装入（动态重定位）：装入程序将装入模块装入到内存之后，地址转化推迟到程序真正执行时进行，可以将程序分配到不连续的存储器，运行时通过重定位寄存器和地址变换机构计算得到地址
### 动态链接
## 扩展
- 内存映射文件：操作系统提供的一个系统调用，将**磁盘文件与虚拟地址空间**之间建立映射关系，以访问内存的形式来访问文件
	- 共享内存通常就是这么实现的（物理内存中的一个内存映射文件被映射到两个不同的虚拟地址空间）
	- 可以像访问内存（数组）那样访问，不需要使用 IO 操作，更为便捷
### 系统调用和 UNIX Shell
#### 操作系统对象
- everything is a file
- 操作系统中的对象要么是**一个文件**要么是**一个字节流**，通过指针（windows 中称为 handle）访问一切
	- 定义（重要）：**文件描述符是指向操作系统对象的指针**

##### 管道与匿名管道
- 一种进程间同步机制 IPC

- 管道：**特殊文件流**
	- 由读者和写者共享
	- 命名管道是一种特殊类型的文件（FIFO），它**存在于文件系统中**，可以被系统中任何知道其名字的进程访问。
	- 读口支持 read；写口支持 write
```c
#define PIPE_NAME "/tmp/my_pipe"
void pipe_read() {
    int fd = open(PIPE_NAME, O_RDONLY);
    char buffer[1024];
    if (fd == -1) {
        perror("open");
        exit(1);
    }
    // Read from the pipe
    int num_read = read(fd, buffer, sizeof(buffer));
    if (num_read > 0) {
        printf("Received: %s\n", buffer);
    } else {
        printf("No data received.\n");
    }
    close(fd);
}
void pipe_write(const char *content) {
    // Open the pipe for writing
    int fd = open(PIPE_NAME, O_WRONLY);
    if (fd == -1) {
        perror("open");
        exit(1);
    }
    // Write the message to the pipe
    write(fd, content, strlen(content) + 1);
    close(fd);
}
int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s read|write [message]\n", argv[0]);
        return 1;
    }
    // Create the named pipe if it does not exist
    if (mkfifo(PIPE_NAME, 0666) == -1) {
        if (errno != EEXIST) {
            perror("mkfifo");
            return 1;
        }
    }
    if (strcmp(argv[1], "read") == 0) {
        pipe_read();
    } else if (strcmp(argv[1], "write") == 0) {
        pipe_write(argv[2]);
    } else {
        fprintf(stderr, "Invalid command. Use 'read' or 'write'.\n");
        return 1;
    }
    return 0;
}

```
- 匿名管道 `int pipe (int pipefd[2]);`
	- 返回两个文件描述符
	- 适用于父子进程通信（如 fork 的），根据 fork 的返回值决定使用哪一个口
	- 匿名管道通常是**单向的**，意味着数据只能在一个方向上流动（可以创建两个匿名管道实现双向通信）。
	- 匿名管道由于**不在文件系统中出现**，不易被其他不相关的进程访问。
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240427213515.png)

```c
void do_parent(int fd) {
    const char *msg = "Hello, world!";
    printf("[%d] Write: '%s'\n", getpid(), msg);
    write(fd, msg, strlen(msg) + 1);
    close(fd);
    // Wait for the child to finish
    wait(NULL);
    printf("[%d] Done.\n", getpid());
}

void do_child(int fd) {
    static char buf[1024];
    ssize_t num_read = read(fd, buf, sizeof(buf));
    if (num_read == -1) {
        perror("read");
        exit(EXIT_FAILURE);
    }
    printf("[%d] Got: '%s'\n", getpid(), buf);
    // Close the read end of the pipe
    close(fd);
}

int main() {
    int pipefd[2];
    // Create a pipe
    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }
    // Fork the current process
    pid_t pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }
    if (pid == 0) {
        // Child
        close(pipefd[1]); // Close unused write end
        do_child(pipefd[0]);
    } else {
        // Parent
        close(pipefd[0]); // Close unused read end
        do_parent(pipefd[1]);
    }
    return 0;
}
```
- **匿名管道**通常用于**父子进程**或具有明确亲缘关系的进程之间的快速通信，如一个进程需要对另一个进程进行直接控制或频繁地传输数据。
- **命名管道**更适用于需要**跨多个不相关进程**进行长时间或复杂交互的场景，如不同组件或程序间需要交换信息但又不方便直接使用更复杂的通信机制（如套接字）的情况。

- pipe 用于连接两个应用程序：
	- pipe read 在没有数据时会等待
	- pipe write 在有读者打开时，写入缓冲区并返回
- 管道异常
	- 如果写者还在运行，但是读者被关闭，就会出现 SIGPIPE 信号
	- 如 `python3 -c 'while True: print(1)' | head -n 1`
#### Unix Shell
- 特殊的应用程序
	- 直接和用户进行交互
	- 配置操作系统，启动、管理其他应用程序
	- 负责把用户指令翻译成系统调用
- 高效简洁精确的自然语言
	- "自然**编程语言**"
	- 一行命令，即可协同多个程序执行

##### 实现 Freestanding shell
### C 语言标准库的实现 libc
- C 是一种 “高级汇编语言”，是系统调用的一层 “**浅封装**”
- 语言机制上的运行库大部分可以用 C 语言本身实现，少部分需要一些 “底层支持”（使用内联汇编）

- [musl](https://musl.libc.org/) 更适合阅读学习的 libc
- 一个 c 程序的完整执行过程
	- 首先在 $\_start$ 有汇编设置一些寄存器
	- $\_start\_c$ 获取参数指针，划分为 argc、argv 等调用 $\_\_libc\_start\_main$，进一步得到 env 等（还有多级初始化）再调用 $main$
	- 执行 $main$
	- 之后在 $exit$ 内再进行一些清理，最后通过 syscall 调用 exit
		- ![image.png|262](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240427113624.png)
#### 计算封装
- 不依赖于系统， Freestanding 环境下也可以使用的定义
- 如 `string.h` 以及 `stdlib.h` 等等都封装了很多使用方法
- 实现这部分库函数 = C 语言课程习题
#### 系统调用与环境抽象
- 如 `printf` 等操作，封装简化了系统调用的使用

#TODO
### linux 操作系统

