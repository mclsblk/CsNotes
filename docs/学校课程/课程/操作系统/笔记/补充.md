### LINUX 相关
- binutils：GNU Binutils 是一组用于处理二进制文件的工具
	- objdump：反汇编二进制文件
	- ld：链接目标文件和库为可执行文件或共享库
	- readelf：显示 ELF 文件信息（节头表、段头表等）
	- nm：显示目标文件的符号表
	- as：将汇编语言代码转化为机器代码
- Coreutils：一组在 Unix 和 Linux 操作系统上使用的**基本命令行工具**的集合
	- ls、cat、cp、mv 等各种常用指令集合
- strace（System call trace）：跟踪一个程序执行期间的**所有系统调用**及其接收到的信号，即用于记录程序运行过程中的系统调用信息
- proc/：特殊文件夹，用于查看进程的信息，如 `/proc/[pid]/maps` 查看进程的地址空间
- `memorymap` 系统调用
	- `mmap` 系统调用用于将文件或设备映射到进程的虚拟地址空间中。
	- `munmap` 系统调用用于解除映射，释放映射的虚拟内存区域。
	- `mprotect` 系统调用用于更改映射区域的内存保护属性
- 输入输出重定向：比如将标准输出重定向 `cat test.txt > file`，打开文件得到一个新的文件描述符，之后将标准输出复制到新的文件描述符即可。三个步骤：打开新描述符、绑定、关闭旧描述符
	- `>` 主要用于将标准输出重定向到文件
	- `|` 管道则是用于将一个命令的输出作为下一个命令的输入

- Shell 执行一个命令时总是会创建新的子进程
	- 如输入 `ls` shell 就睡 `fork` 一个子进程用于执行命令，父进程等待子进程执行完成之后再做进一步的处理
- `|` 管道命令的实现原理
	- Shell 通过创建管道、**fork 子进程**和重定向标准输入输出来实现功能
	- 对于 `command1 | command2 ` Shell 首先创建一个管道，fork 出两个子进程分别用于执行两条命令，其中第一个子进程重定向输出到管道写口，第二个子进程重定向输入到管道读口
	- 管道两侧的命令本质上是并行执行的两个进程，通过管道进行数据传递
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    int pipefd[2];
    pid_t pid1, pid2;

    // 创建管道
    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    // 创建第一个子进程，执行 command1
    pid1 = fork();
    if (pid1 == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (pid1 == 0) {
        // 子进程 1
        close(pipefd[0]);  // 关闭读端
        dup2(pipefd[1], STDOUT_FILENO);  // 将标准输出重定向到写端
        close(pipefd[1]);  // 关闭写端
        execlp("ls", "ls", "-l", (char *)NULL);  // 执行 command1
        perror("execlp");
        exit(EXIT_FAILURE);
    }

    // 创建第二个子进程，执行 command2
    pid2 = fork();
    if (pid2 == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (pid2 == 0) {
        // 子进程 2
        close(pipefd[1]);  // 关闭写端
        dup2(pipefd[0], STDIN_FILENO);  // 将标准输入重定向到读端
        close(pipefd[0]);  // 关闭读端
        execlp("grep", "grep", ".c", (char *)NULL);  // 执行 command2
        perror("execlp");
        exit(EXIT_FAILURE);
    }

    // 父进程
    close(pipefd[0]);  // 关闭管道读端
    close(pipefd[1]);  // 关闭管道写端

    // 等待子进程结束
    waitpid(pid1, NULL, 0);
    waitpid(pid2, NULL, 0);

    return 0;
}

```