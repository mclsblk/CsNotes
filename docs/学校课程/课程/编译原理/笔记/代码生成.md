- 任务
	- 指令选择：选择适当的指令实现 IR 语句
	- 寄存器的分配和指派
	- 指令排序：按照什么顺序安排指令的执行
- 输出 RISC、CISC 等
### 对目标机的约定（本课程中）
- 指令：
	- 加载：`LD dst, addr` (把地址 addr **中的内容**加载到 dst 所指的寄存器) 相当于进行了**解引用**
	- 保存：`ST x, r` (把寄存器 r 中的内容保存到 x 中)
	- 计算：`OP dst, src 1, src 2` (把 src 1 和 src 2 中的值运算后将结果存放到 dst 中)
	- 无条件跳转：`BR L` (控制流转向标号 L 的指令)
	- 条件跳转：`Bcond r, L` (对 r 中的值进行测试，如果为真则转向 L)
- 寻址模式
	- 变量 `x`：指向分配 x 的内存位置
	- `a (r)`：地址是 a 的左值加上寄存器 r 中的值
	- `constant (r) `：寄存器 r 中内容加上前面的常数即其地址
	- `*r `：寄存器 r 的内容所表示的位置上存放的内容位置
	- `*constant (r) `：寄存器 r 中内容加上常数所代表的位置上的内容所表示的位置
	- 常数 `#constant `
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511134033.png)
- ![|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511130727.png)
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511130740.png)
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511130750.png)
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511130757.png)
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511134052.png)

#### 过程调用与返回
- 静态分配：
	- call：先 `ST callee.staticArea, #here + 20` 存储返回地址；然后 `BR callee.codeArea` 跳转到过程调用
	- return：`BR *callee.staticArea`
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511132456.png)

- 栈式分配：
	- call：`ADD SP, SP, #caller.recordSize` 增大栈指针；`ST 0(SP), #here + 16` 保存返回地址；`BR callee.codeArea` 转移到被调用者
	- return：`BR *0(SP) ` 被调用者执行，返回调用者（返回地址）；`SUB SP, SP, #caller.recordSize` 调用者减小栈指针
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511133136.png)
[[docs/学校课程/课程/编译原理/作业/p10#^ae41a5|8.2.2&8.2.4]]
### 基本块和流图
- 将中间代码划分为**基本块**，控制流只能从基本块的第一条指令进入，除了基本块的最后一条指令，控制流不会进行跳转/停机
- **流图**的节点就是基本块，流图的边说明了基本块之间的运行关系
	- 指出了基本块之间的控制流，可以确认一个值是否会被使用
	- 是进行优化的基础
- 基本块的划分：三地址指令序列->基本块的列表
	- 首先找到首指令：**第一个三地址指令；转移指令的目标指令；转移指令之后的指令**
	- 每个首指令就对应一个基本块，块的范围就是从一个首指令开始到下一个首指令之前
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511140045.png)
- 流图的构造
	- 两个节点之间存在一条边 $A\to B\iff$ B 的第一个指令可能在 A 的最后一个指令之后执行；称 A 为 B 的前驱；B 为 A 的后驱
	-  入（出）口节点：**入口到第一条指令**有一条边；任何可能**最后执行的基本块到出口**有一条边
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511142213.png)

- 循环
	- **循环入口**：唯一的**前驱可以在循环 L 之外**的结点，到达其余结点的路径必然先经过这个入口结点；其余结点都存在到达入口结点的非空路径，且**路径都在 L 中**
	- 一个循环是流图中一个结点集合
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511143636.png)

#### 优化
- 活跃性与后续使用
	- 设在语句 i 对 x 进行了赋值，若存在从 i 到 j 的路径并且路径上没有对 x 进行赋值、j 使用了 x 的值，就称 j 使用了 i 处计算得到的 x 的值
	- 即变量 x 在语句 i 后的程序点上**活跃**（x 在 i 时存放的**值**会被使用）
	- 可以用于寄存器优化等（即数据是否还需要存储，还有用吗）
- 确定基本块中的活跃性与后序使用
	- 对于基本块 𝐵 中的每个**非临时变量**，初始时认为它们在块的末尾是**活跃的**。
	- 从基本块 𝐵 的末尾开始，逐条**反向检查**每条语句。
	- 对于每个语句 i：x = y + z：
		- **更新 𝑥**：将 𝑥 设置为“不活跃”，因为 𝑥 的旧值在此语句之后不再被使用；
		- **更新 𝑦 和 𝑧**：将 𝑦 和 𝑧 设置为“活跃”，此更新反映了在当前语句中使用了 𝑦 和 𝑧 的值。
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511141312.png)
#### DAG 分析
- DAG 图可反映变量及其值对其他变量的依赖关系 (各变量的值之间的关系)
- 使用 DAG 可以实现
	- 寻找局部公共子表达式
	- 消除死代码
	- 代数恒等式的使用
	- 数组引用的表示
	- 指针赋值和过程调用

- DAG 图的建立
	- **每个变量**都有一个对应的 DAG 结点表示其**初始值**
	- **每个语句** s 有一个相关的结点 N，代表此计算得到的值；节点 𝑁 的子节点是构成该语句的运算分量的当前值。在 `x = y + z` 的例子中，𝑦 和 𝑧 将是 𝑁 的子节点。
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511170459.png)
	- 扫描结束后，对所有在出口处活跃的变量 x，将 x 所关联的结点设置为输出结点
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511170942.png)
[[p11]]
- 局部公共子表达式
	- 建立某个结点 M 之前，检查是否存在一个结点 N，它和 M **具有相同的运算符和子结点**
	- 如果存在则可以直接使用 N 来代表 M，不再需要生成新的节点
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511171224.png)
	- （b+c）不是，因为 b 的值改变了
- 消除死代码
	- 在 DAG 图上**消除没有附加活跃变量**（未来使用如作为返回值或输出等）的**根结点**，即消除死代码
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511171500.png)
- 代数恒等式优化
	- 恒等式：$x + 0 = 0 + x = x, x – 0 = x$ 等
	- 简化运算 $x^2=x*x,x/2=x*0.5$ 等
	- 常量编译时计算、合并
	- 利用代数规则（交换律、结合律）
- 数组引用
	- 数组有两种操作：
		- 取数：`=[]` 左子节点为数组（起始）地址 $a$，右子节点为下标 $i$
		- 存数：`[]=` 三个子节点分别表示：数组（起始）地址 $a$，下标 $i$，要存储的值 $x$
	- 出现一个存数操作后，所有依赖于该数组的执勤啊节点都应该被“**杀死**”不能再被复用（尤其是写入的下标为变量时）
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511172455.png)
- 指针赋值和过程调用
	- 通过指针访问和数组类似，可以分为写和读两种操作
	- 由于通过指针取值可以访问任何元素，这就给死代码的消除带来很大困扰；而通过指针进行赋值又可能会杀死全部其他节点
	- 可通过 (全局/局部) 指针分析部分地解决这个问题
	- 这两种操作都具有很大的不确定性

- 从 DAG 到基本块的重组
	- 方法：**每个结点构造一个三地址语句**，计算对应的值；结果应该尽量赋给一个活跃的变量；如果结点有多个关联的变量，则需要用复制语句进行赋值
	- 规则：如果两个指令之间相互影响，它们的顺序就不该改变
		- 对数组赋值要跟在原来之前的赋值/求值之后
		- 对数组求值要跟在原来之前的赋值指令之后
		- 对变量的使用必须跟在所有原来在它之前的过程调用和指针间接赋值之后
		- 任何过程调用或指针间接赋值必须跟在原来在它之前的变量求值之后
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511172635.png)

### 代码生成算法
- 根据三地址指令序列生成机器指令
- 主要的目标是**减少加载和保存**（IO）指令，即最大限度地利用寄存器
	- 只有当运算分量不在寄存器中时，才从内存载入
	- 尽量保证只有当寄存器中值不被使用时，才覆盖掉
- 寄存器描述符：跟踪各个寄存器都**存放了哪些**变量的当前值
- 地址描述符：各个变量的当前值**存放在哪些位置**上

#### 寄存器分配和指派
- 寄存器分配：那个值应该放在寄存器里
- 寄存器指派：值应该存放在哪个寄存器里
- 在循环中**频繁使用**的值存放在固定寄存器
	- 可以通过使用计数 的方法来估算把一个变量放到寄存器中会带来多大好处，然后根据这个估算来分配寄存器

- **`Reg()`** 函数根据寄存器描述符和地址描述符等数据流信息，为三地址指令 I **选择最佳的寄存器**，进一步决定了得到的机器指令的质量
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511173904.png)
- 代码生成同时更新寄存器和地址描述符
	- 对于 `LD R, x`：R 寄存器描述符-只包含 x；x 地址描述符-添加 R 到地址集合；将 R 从其他变量的地址描述符中删除
	- 对于 `ST x, R`：x 的地址描述符添加存储的内存地址
	- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511174203.png)

-  ![[Chapter_8.pdf#page=46&selection=0,0,0,2|Chapter_8, page 46]]
- 如果要使用的运算分量不在寄存器重并且没有空闲寄存器
	- 寻找一个寄存器 R，其寄存器描述符表示 v 在 R 中
	- 如果 v 还存储在其他位置，则直接替换
	- v 就是运算结果并且不参与运算，直接替换
	- 如果 v 之后不会被使用了，直接替换
	- 否则需要生成 `ST v` 将 R 中存放的所有值**逐一存储到内存**
[[p12#^c39f28|8.6.5]]
#### 窥孔优化
- 使用一个滑动窗口 (窥孔) 来检查目标指令，在窥孔内实现优化
	- 冗余指令消除
	- 控制流优化
	- 代数化简
	- 机器特有指令的使用
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511175704.png)
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511175712.png)
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511175725.png)
#### 目标指令生成
- 同一个三地址指令可以使用多种机器指令实现，有时多个三地址指令可以使用一个机器指令实现
- 用**树来表示中间代码**，按照特定的规则不断**覆盖这棵树**并生成机器指令
	- 即通过应用一个**树重写规则**序列来生成，称为一个**树翻译方案**
	- 从一个抽象语法树（中间代码）翻译得到目标代码树（机器语言）
	- 如果找到一个匹配的模板，那么输入树中匹配的子树将被替换为相应规则中的**替换结点**，并执行相应的动作
	- 不断匹配，直到这颗树被规约成单个结点，或找不到匹配的模板为止
	- 在此过程中生成的机器指令代码序列就是树翻译方案作用于给定输入树而得到的输出
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511181218.png)
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511181227.png)

- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511182259.png)
- ![image.png|500](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240511181803.png)
	- 这里使用栈寻址（局部变量，因此是相对 Rsp 的偏移量）