{"path":"docs/学校课程/课程/编译原理/课件/Chapter_6.pdf","text":"许畅 南京大学计算机系 2024年春季 第六章 中间代码生成 版权所有 南京大学计算机科学与技术系 许畅 2024春季版 本章内容 • 中间代码表示 – 表达式的有向无环图DAG – 三地址代码：x = y op z • 类型检查 – 类型、类型检查、表达式的翻译 • 中间代码生成 – 控制流、回填 2 编译器前端的逻辑结构 • 前端是对源语言进行分析并产生中间表示 • 处理与源语言相关的细节，与目标机器无关 • 前端后端分开的好处：不同的源语言、不同的机 器可以得到不同的编译器组合 (m × n) 3 中间代码表示及其好处 • 形式 – 多种中间表示，不同层次 – 抽象语法树 – 三地址代码 • 重定位 – 为新的机器建编译器，只需要做从中间代码到新的目 标代码的翻译器 (前端独立) • 高层次的优化 – 优化与源语言和目标机器都无关 4 中间代码的实现 • 静态类型检查和中间代码生成的过程都可以用语 法制导的翻译来描述和实现 • 对于抽象语法树这种中间表示的生成，第五章已 经介绍过 5 生成抽象语法树的语法制导定义 • a + a * (b – c) + (b – c) * d的抽象语法树 6 表达式的有向无环图 • 语法树中，公共子表达式每出现一次，就有一颗 对应的子树 • 表达式的有向无环图 (Directed Acyclic Graph, DAG) 能够指出表达式中的公共子表达式，更简 洁地表示表达式 7 DAG构造 • 可以用和构造抽象语法树一样的SDD来构造 • 不同的处理 – 在函数Leaf和Node每次被调用时，构造新节点前先检查 是否存在同样的结点 (值编码+散列表)，如果已存在， 则返回这个已有结点 • 构造过程示例 8 三地址代码 (1) • 每条指令右侧最多有一个运算符 – 一般情况可以写成x = y op z • 允许的运算分量 (地址) – 名字：源程序中的变量名字作为三地址代码的地址 – 常量：源程序中出现或生成的常量 – 编译器生成的临时变量 9 三地址代码 (2) • 指令集合 (1) – 运算/赋值指令： x = y op z x = op y – 复制指令： x = y – 无条件转移指令： goto L – 条件转移指令： if x goto L if False x goto L – if x relop y goto L 10 三地址代码 (3) • 指令集合 (2) – 过程调用/返回 • param x1 // 设置参数 • param x2 • … • param xn • call p, n // 调用过程p，n为参数个数 (可能嵌套调用) – 带下标的复制指令：x = y[i] x[i] = y • i表示距离数组位置i个内存单元 (字节)，不是数组的第i个元素 – 地址/指针赋值指令 • x = &y x = *y *x = y 11 例子 • 语句 – do i = i + 1; while (a[i] < v); 12 四元式表示 • 在实现时，可使用四元式/三元式/间接三元式/静 态单赋值来表示三地址指令 • 四元式 (quadruple)：可以实现为记录 (或结构) – 格式 (字段) ： op arg1 arg2 result – op：运算符的内部编码 – arg1, arg2, result是地址 – x = y + z + y z x • 单目运算符不使用arg2 • param运算不使用arg2和result • 条件/非条件转移将目标标号放在result字段 13 四元式的例子 • 赋值语句：a = b * − c + b * − c 14 三元式表示 • 三元式 (triple) ： op arg1 arg2 • 使用三元式的位置来引用三元式的运算结果 • x = y op z需要拆分为 (?是位置) – ? op y z – = x (?) • x[i] = y需要拆分为两个三元式 (x = y[i]类似) – 求x[i]的地址，然后再赋值 • 优化时经常需要移动/删除/添加三元式，导致三元 式运算结果的位置变化 (四元式无此问题) 15 三元式的例子 16 间接三元式表示 • 间接三元式 (indirect triple)：包含了一个指向三 元式的指针的列表 – 可对该列表进行操作 (重新排序)，完成优化功能， 操作时不影响三元式本身 17 静态单赋值形式 • 静态单赋值 (SSA)：所有赋值都是针对具有不同 名字的变量 • 对于同一个变量在不同路径中定值的情况，可以 使用φ函数来合并不同的定值 – if (flag) x = −1; else x = 1; y = x * a; – if (flag) x1 = −1; else x2 = 1; x3 = φ(x1, x2); y = x3 * a; 18 p = a + b q = p – c p = q * d p = e – p q = p + q p1 = a + b q1 = p1 – c p2 = q1 * d p3 = e – p2 q2 = p3 + q1 => 类型和声明 • 类型检查 (type checking) – 利用一组规则来检查运算分量的类型和运算符的预期 类型是否匹配 • 类型信息的用途 – 查错、确定名字需要的内存空间、计算数组元素的地 址、类型转换、选择正确的运算符 • 本节的内容 – 确定名字的类型 – 变量的存储空间布局 (相对地址) 19 类型表达式 • 类型表达式 (type expression)：表示类型的结构 – 可能是基本类型 – 也可能通过类型构造算子作用于类型表达式而得到 • 如int [2][3]，表示由两层数组组成的数组 – array(2, array(3, integer)) – array是类型构造算子，有两个参数：数字和类型 20 类型表达式的定义 • 基本类型 (或类型名) 是一个类型表达式 – 如：boolean, char, integer, float, void, … • 类型构造算子array作用于数字和类型表达式得到 一个类型表达式，record作用于字段名和相应的 类型得到一个类型表达式 • 类型构造算子→可得到函数类型的类型表达式 • 如果s和t是类型表达式，其笛卡尔积s × t也是类型 表达式 (描述列表或元组，如函数参数) – 如：struct { int a[10]; float f; } st; – 对应于：record((a × array(0..9, int)) × (f × real)) 21 类型等价 • 不同的语言有不同的类型等价的定义 • 结构等价 (structurally equivalent) – 它们是相同的基本类型，或 – 由相同的构造算子作用于结构等价的类型而得到，或 – 一个类型是另一个类型表达式的名字 • 名等价 (name equivalence) – 类型名仅代表自身 (仅有前两个条件) 22 类型的声明 • 处理基本类型、数组类型或记录类型的文法 – D  T id; D | ε – T  B C | record '{' D '}' – B  int | float – C  ε | [num] C • 应用该文法及其对应的语法制导定义，除了得到 类型表达式之外，还得进行各种类型的存储布局 23 局部变量的存储布局 • 变量的类型可以确定变量需要的内存 – 即类型的宽度 (该类型一个对象所需的存储单元的数量) – 可变大小的数据结构 (如动态数组) 只需要考虑指针 – 特殊：对齐 (aligned)、补白 (padding)、压缩 (pack) • 函数的局部变量总是分配在连续的区间 – 因此给每个变量分配一个相对于这个区间开始处的相 对地址 • 变量的类型信息保存在符号表中 24 计算T的类型和宽度的SDT • 综合属性：type, width – 全局变量t和w用于将类型和宽度信息从B传递到C  ε – 相当于C的继承属性 (也可以把t和w替换为C.t和C.w) 25 { { ; } SDT运行的例子 • 输入：int [2][3] 26 声明序列的SDT (1) • 在处理一个过程/函数时，局部变量应该放到单独 的符号表中去 • 这些变量的内存布局独立 – 相对地址从0开始，变量的放置和声明的顺序相同 • SDT的处理方法 – 变量offset记录当前可用的相对地址 – 每分配一个变量，offset增加相应的值 (加宽度) • top.put(id.lexeme, T.type, offset) – 在符号表中创建条目，记录标识符的类型和偏移量 27 声明序列的SDT (2) • 可以把offset看作D的继承属性 – D.offset表示D中第一个变量的相对地址 – P  { D.offset = 0; } D – D  T id; { D1.offset = D.offset + T.width; } D1 28 记录和类中的字段 (1) • 记录变量声明的翻译方案 • 约定 – 一个记录中各个字段的名字必须互不相同 – 字段名的偏移量 (相对地址)，是相对于该记录的数据 区字段而言的 • 记录类型使用一个专用的符号表，对其各个字段 的类型和相对地址进行编码 • 记录类型record(t)：record是类型构造算子，t是 符号表对象，保存该记录类型各个字段的信息 29 记录和类中的字段 (2) 30 注：记录类型存储方式可以推广到类 表达式代码的SDD • 将表达式翻译 成三地址代码 的SDD – code表示代码 – addr表示存放 表达式结果的 地址 – new Temp()生 成临时变量 – gen()生成指令 31 a = b + − c 增量式翻译方案 • 类似于上一章中所述的边扫描边生成 • gen不仅构造新的三地址指令，还要将它添加到至今为止 已生成的指令序列之后 • 不需要code指令保存已有的代码，而是对gen的连续调用生 成一个指令序列 32 数组元素的寻址 • 假设数组元素被存放在连续的存储空间中，元素 从0到n−1编号，第i个元素的地址为：base + i * w – 若从low到high，则地址为：base + (i – low) * w • k维数组的寻址：假设数组按行存放，首先存放 A[0][i2]…[ik]，然后存放A[1][i2]…[ik]，…，那么 A[i1][i2]…[ik]的地址为 – base + i1 * w1 + i2 * w2 + … + ik * wk，或者 – base + ((…((i1 * n2 + i2) * n3 + i3)…) * nk + ik) * w – 其中base, w, n的值可以从符号表中找到 33 数组引用的翻译 • 为数组引用生成代码要解决的主要问题 – 数组引用的文法和地址计算相关联 • 假定数组编号从0开始，基于宽度来计算相对地址 • 数组引用相关文法 – 非终结符号L生成数组名，加上一个下标表达式序列 34 数组引用生成代码的翻译方案 (1) • 非终结符号L的三个综合属性 – L.array是一个指向数组名字对应的符号表条目的指针 • L.array.base为该数组的基地址 – L.addr指示一个临时变量，计算数组引用的偏移量 – L.type是L生成的子数组的类型 • 对于任何 (子) 数组类型L.type，其宽度由L.type.width给出， L.type.elem给出其数组元素的类型 35 数组引用生成代码的翻译方案 (2) • 核心是确定数组引用的地址 36 数组引用生成代码的翻译方案 (3) • L的代码只计算了偏移量 • 数组元素的存放地址应该根据偏移量进一步计算， 即L的数组基址加上偏移量 • 使用三地址指令x = a[i] 37 数组引用生成代码的翻译方案 (4) • 使用三地址指令a[i] = x 38 例子 • 表达式：c + a[i][j] 39 类型检查和转换 • 类型系统 (type system) – 给每一个组成部分赋予一个类型表达式 – 通过一组逻辑规则来表达类型表达式必须满足的条件 – 可发现错误、提高代码效率、确定临时变量的大小 • 类型检查可以分为动态和静态两种 • 如果编译器中的类型系统能够保证它接受的程序 在运行时刻不会发生类型错误，则该语言的这种 实现称为强类型的 40 类型系统的分类 • 类型综合 (type synthesis) – 根据子表达式的类型构造出表达式的类型 if f 的类型为s  t且x的类型为s then f(x)的类型为t • 类型推导 (type inference) – 根据语言结构的使用方式来确定该结构的类型 if f(x)是一个表达式 then 对于某些类型α和β，f的类型为α  β且x的类型为α 41 类型转换 • 假设在表达式x * i中，x为浮点数，i为整数，则结 果应该是浮点数 – x和i使用不同的二进制表示方式 – 浮点*和整数*使用不同的指令 – t1 = (float) i t2 = x fmul t1 • 类型转换比较简单时的SDT – E  E1 + E2 { if (E1.type = integer and E2.type = integer) E.type = integer; else if (E1.type = float and E2.type = integer) E.type = float; … } 42 类型转换规则 • Java的类型转换规则 – 拓宽 (widening) 和窄化 (narrowing) • 编译器自动完成的转换为隐式转换，程序员用代 码指定的转换为显式转换 43 处理类型转换的SDT • 函数max求两个参数 在拓宽层次结构中 的最小公共祖先 • 函数widen生成必要 的类型转换代码 44 函数/运算符的重载 • (只考虑) 通过查看参数来解决函数重载问题 • E  f(E1) { if f.typeset = { si  ti | 1 <= i <= n } and E1.type = sk then E.type = tk } 45 控制流的翻译 • 布尔表达式可以用于改变控制流/计算逻辑值 • 文法 – B  B ‖ B | B && B | ! B | ( B ) | E rel E | true | false • 语义 – B1 ‖ B2中B1为真时，不计算B2，整个表达式为真，因此， 当B1为真时应该跳过B2的代码 – B1 && B2中B1为假时，不计算B2，整个表达式为假 • 短路代码 – 通过跳转指令实现控制流，逻辑运算符本身不出现 46 短路代码的例子 • 语句 – if (x < 100 ‖ x > 200 && x != y) x = 0; • 代码 – if x < 100 goto L2 – if False x > 200 goto L1 – if False x != y goto L1 – L2: x = 0 – L1: 接下来的代码 47 控制流语句的翻译 • 控制流语句 – S  if (B) S1 – S  if (B) S1 else S2 – S  while (B) S1 • 继承属性 – B.true：B为真时的 跳转目标 – B.false：B为假时的 跳转目标 – S.next：S执行完毕 时的跳转目标 48 语法制导的定义 (1) 49 • 增量式生成代码 S  while ( { begin = newlabel(); B.true = newlabel(); B.false = S.next; gen(begin ':'); } B ) { S1.next = begin; gen(B.true ':'); } S1 { gen('goto' begin); } 语法制导的定义 (2) 50 布尔表达式的控制流翻译 • 生成的代码执行时跳转到两个标号之一 – 表达式的值为真时，跳转到B.true – 表达式的值为假时，跳转到B.false • B.true和B.false是两个继承属性，根据B所在的上 下文指向不同的位置 – 如果B是if语句条件表达式，分别指向then和else分支； 如果没有else分支，则B.false指向if语句的下一条指令 – 如果B是while语句的条件表达式，分别指向循环体的 开头和循环出口处 51 布尔表达式的代码的SDD (1) 52 // 短路 // 短路 布尔表达式的代码的SDD (2) 53 布尔表达式代码的例子 • if (x < 100 ‖ x > 200 && x != y ) x = 0; 的代码 54 生成的中间代码 优化过的中间代码 布尔值和跳转代码 • 程序中出现布尔表达式也可能是求值：x = a < b • 处理方法 – 建立表达式的语法树，根据表达式的不同角色来处理 • 文法 – S  id = E; | if (E) S | while (E) S | S S – E  E ‖ E | E && E | ! E | E rel E | … • 根据E的语法树结点所在的位置 – S  while ( E ) S1中的E，生成跳转代码 – 对于S  id = E，生成计算右值的代码 55 回填 (1) • 为布尔表达式和控制流语句生成目标代码 – 关键问题：某些跳转指令应该跳转到哪里？ • 例如：if (B) S – 按照短路代码的翻译方法，B的代码中有一些跳转指令 在B为假时执行 – 这些跳转指令的目标应该跳过S对应的代码，但生成这 些指令时，S的代码尚未生成，因此目标不确定 – 通过语句的继承属性next来传递，需要第二趟处理 • 如何一趟处理完毕呢？ 56 回填 (2) • 基本思想 – 记录B中跳转指令如goto S.next的标号，但不生成跳转 目标，这些标号被记录到B的综合属性B.falselist中 – 当S.next的值成为已知时 (即S的代码生成完毕时)，把 B.falselist中的所有指令的目标都填上这个值 • 回填技术 – 生成跳转指令时不指定跳转目标，而是使用列表记录 这些不完整指令的标号 – 当知道正确的跳转目标时再填写目标 – 列表中的每个指令都指向同一个目标 57 布尔表达式的回填翻译 (1) • 布尔表达式在取值true/false时分别跳转到某目标 • 综合属性 – truelist：包含跳转指令标号的列表，这些指令在取值 true时执行 – falselist：包含跳转指令标号的列表，这些指令在取值 false时执行 • 辅助函数 – makelist(i)：创建一个包含跳转指令标号i的列表 – merge(p1, p2)：将p1和p2指向的标号列表合并然后返回 – backpatch(p, i)：将i作为跳转目标插入p的所有指令中 58 布尔表达式的回填翻译 (2) 59 • 文法中引入 非终结符号 M • 在适当的时 候获取将要 生成指令的 标号 回填和非回填方法的比较 (1) • 比较 – 生成指令坯，然后加入相应的list – 原来跳转到B.true的指令，现在加入到B.truelist中 – 原来跳转到B.false的指令，现在加入到B.falselist中 60 回填和非回填方法的比较 (2) 61 • true/false属性的赋值，在回填方案中对应为相应 的truelist/falselist的赋值或者merge 布尔表达式的回填例子 • x < 100 || x > 200 && x != y 62 _ 控制转移语句的回填翻译 (1) • 语句 – S  if ( B ) S | if ( B ) S else S | while ( B ) S – | { L } | A – L  L S | S • 综合属性nextlist – nextlist中跳转指令的目标是S执行完毕后紧接着执行的 下一条指令的标号 – 考虑S是if语句、while语句的子语句时，分别应该跳转 到哪里？ 63 控制转移语句的回填翻译 (2) • M：用M.instr记录下一条指令的标号 • N：生成goto指令坯，N.nextlist包含该指令标号 64 控制转移语句的回填翻译 (3) 65 Break/Continue语句的处理 • 虽然break和continue在语法上是一个独立的句子， 但是它们的代码与外围语句相关 • 方法：(break语句) – 跟踪外围循环语句S – 生成一个跳转指令坯 – 将这个指令坯的位置加入到S的nextlist中 66 Switch语句的处理 • n路分支 – 可用条件跳转指令序列或散列表实现 67 测试放末端 测试放前端 过程的中间代码 • 如：赋值语句 – a是一个整数数组，f是一个从整数到整数的函数 • 可被翻译为三地址代码 68 n = f(a[i]) 1) t1 = i * 4 2) t2 = a [ t1 ] 3) param t2 4) t3 = call f, 1 5) n = t3","libVersion":"0.3.2","langs":""}