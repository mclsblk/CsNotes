{"path":"docs/学校课程/归档课程/编译原理/作业/答案/dragon-book-exercise-answers-master/ch04/4.4/courses.engr.illinois.edu-cs373-lec14.pdf","text":"1 Three Simpliﬁcations Motivation for Grammar Simpliﬁcation Parsing Problem Given a CFG G and string w, determine if w ∈ L(G). • Fundamental problem in compiler design and natural language processing. If G is in general form then the procedure maybe very ineﬃcient. So the grammar is “transformed” into a simpler form to make the parsing problem easier. 1.1 Eliminating ϵ-productions Eliminating ϵ-productions • Often would like to ensure that the length of the intermediate strings in a derivation are not longer than the ﬁnal string derived • But a long intermediate string can lead to a short ﬁnal string if there are ϵ-productions (rules of the form A → ϵ). • Can we rewrite the grammar not to have ϵ-productions? Eliminating ϵ-production The Problem Given a grammar G produce an equivalent grammar G′ (i.e., L(G) = L(G′)) such that G′ has no rules of the form A → ϵ, except possibly S → ϵ, and S does not appear on the right hand side of any rule. Note: If S can appear on the RHS of a rule, say S → SS, then when there is the rule S → ϵ, we can again have long intermediate strings yielding short ﬁnal strings. We will ﬁrst introduce a concept that will be useful in this transformation. Nullable Variables Deﬁnition 1. A variable A (of grammar G) is nullable if A ∗ ⇒ ϵ. How do you determine if a variable is nullable? • If A → ϵ is a production in G then A is nullable • If A → B1B2 · · · Bk is a production and each Bi is nullable, then A is nullable. • Repeat the above steps until no new nullable variables can be found. 1 Using nullable variables Intuition For every variable A in G have a variable A in G′ such that A ∗ ⇒G′ w iﬀ A ∗ ⇒G w and w ̸= ϵ. For every rule B → CAD in G, where A is nullable, add two rules in G′: B → CD and B → CAD. The Algorithm • If G = (V, Σ, R, S) then G′ = (V ∪ {S′}, Σ, R′, S′) where S′ ̸∈ V . • And the set R′ will be deﬁned as follows. For each rule A → X1X2 · · · Xk in G, create rules A → α1α2 · · · αk where αi = { Xi if Xi is a non-nullable variable/terminal in G Xi or ϵ if Xi is nullable in G and not all αi are ϵ • Add rule S′ → S. If S nullable in G, add S′ → ϵ also. Correctness of the Algorithm Leftmost Derivations Before proving the correctness, we will introduce the notion of a leftmost derivation. A derivation A ∗ ⇒ w is a leftmost derivation if every step of the derivation is obtained by applying a rule to the leftmost variable; we will denote this by A ∗ ⇒lm w. Example 2. Let G = ({S, A, B}, {a, b}, {S → AB, A → aA | a, B → bB | b}, S). The derivation S ⇒ AB ⇒ aB ⇒ ab is a leftmost derivation. However, S ⇒ AB ⇒ Ab ⇒ ab is not a leftmost derivation. A few properties of leftmost derivations are useful to observe. • Our proof constructing a derivation corresponding to a parse tree constructed a leftmost derivation. • Therefore, A ∗ ⇒ w iﬀ A ∗ ⇒lm w. • A grammar G = (V, Σ, R, S) is ambiguous iﬀ there is w ∈ Σ∗ such that w has two (diﬀerent) parse trees with root S and yield w iﬀ there is w ∈ Σ∗ such that there are two (diﬀerent) leftmost derivation of w from S. • For w ∈ Σ∗, a leftmost derivation A ∗ ⇒lm w has the form A ⇒ X1X2 · · · Xk ∗ ⇒lm w1X2 · · · Xk ∗ ⇒lm w1w2X3 · · · Xk · · · ∗ ⇒lm w1w2 · · · wk = w 2 where wi ∈ Σ∗, and wi = Xi if Xi ∈ Σ. That is, the derivation applies a rule to A, and then applies a sequence of steps to the leftmost symbol until we get a string of terminals (and no steps if the leftmost symbol is not a variable), and then sequence of steps the second symbol, and so on. Thus, here we have Xi ∗ ⇒lm wi. Eliminating ϵ-productions An Example Example 3. Let G = ({S, A, B}, {a, b}, R, S) where R is given by: S → AB; A → AaA|ϵ; and B → BbB|ϵ. • Nullables in G are A, B and S • G′ will have variables {S′, S, A, B} and rules: – S → AB|A|B – A → AaA|aA|Aa|a – B → BbB|bB|Bb|b – S′ → S|ϵ 1.2 Eliminating Unit Productions Eliminating Unit Productions • Often would like to ensure that the number of steps in a derivation are not much more than the length of the string derived • But can have a long chain of derivation steps that make little or no “progress,” if the grammar has unit productions (rules of the form A → B, where B is a non-terminal). – Note: A → a is not a unit production • Can we rewrite the grammar not to have unit-productions? Eliminating unit-productions Given a grammar G produce an equivalent grammar G′ (i.e., L(G) = L(G′)) such that G′ has no rules of the form A → B where B ∈ V ′. Role of Unit Productions Unit productions can play an important role in designing grammars: • While eliminating ϵ-productions we added a rule S′ → S. This is a unit production. 3 • We have used unit productions in building an unambiguous grammar: I → a | b | Ia | Ib T → F | T ∗ F N → 0 | 1 | N 0 | N 1 E → T | E + T F → I | N | − N | (E) But as we shall see now, they can be (safely) eliminated Eliminating Unit Productions Basic Idea Introduce new “look-ahead” productions to replace unit productions: look ahead to see where the unit production (or a chain of unit productions) leads to and add a rule to directly go there. Example 4. E → T → F → I → a|b|Ia|Ib. So introduce new rules E → a|b|Ia|Ib But what if the grammar has cycles of unit productions? For example, A → B|a, B → C|b and C → A|c. You cannot use the “look-ahead” approach, because then you will get into an inﬁnite loop. The Algorithm 1. Determine pairs ⟨A, B⟩ such that A ∗ ⇒u B, i.e., A derives B using only unit rules. Such pairs are called unit pairs. • Easy to determine unit pairs: Make a directed graph with vertices = V , and edges = unit productions. ⟨A, B⟩ is a unit pair, if there is a directed path from A to B in the graph. • Note, it is possible to A ∗ ⇒ B without using unit productions. Example, A → BC and C → ϵ. 2. If ⟨A, B⟩ is a unit pair, then add production rules A → β1|β2| · · · βk, where B → β1|β2| · · · |βk are all the non-unit production rules of B 3. Remove all unit production rules. Proposition 5. Let G′ be the grammar obtained from G using this algorithm to eliminate unit productions. Then L(G′) = L(G) 1.3 Eliminating Useless Symbols Eliminating Useless Symbols • Ideally one would like to use a compact grammar, with the fewest possible variables • But a grammar may have “useless” variables which do not appear in any valid derivation 4 • Can we identify all the useless variables and remove them from the grammar? (Note: there may still be other redundancies in the grammar.) Useless Symbols Deﬁnition 6. A symbol X ∈ V ∪Σ is useless in a grammar G = (V, Σ, S, P ) if there is no derivation of the form S ∗ ⇒ αXβ ∗ ⇒ w where w ∈ Σ∗ and α, β ∈ (V ∪ Σ)∗. Removing useless symbols (and rules involving them) from a grammar does not change the language of the grammar. We can say X is useless iﬀ either Type 1: X is not “reachable” from S (i.e., no α, β such that S ∗ ⇒ αXβ), or Type 2: for all α, β such that S ∗ ⇒ αXβ, either α, X or β cannot yield a string in Σ∗. i.e., either Type 2a: X is not “generating” (i.e., no w ∈ Σ∗ such that X ∗ ⇒ w), or Type 2b: α or β contains a non-generating symbol Algorithm to Remove Useless Symbols Algorithm So, in order to remove useless symbols, 1. First remove all symbols that are not generating (Type 2a) • If X was useless, but reachable and generating (i.e., Type 2b) then X becomes unreach- able after this step – Type 2b: for all α, β such that S ∗ ⇒ αXβ, α or β contains a non-generating symbol. Then in the new grammar all such derivations disappear (because some variable in α or β is removed). 2. Next remove all unreachable symbols in the new grammar. • Removes Type 1 (originally unreachable) and Type 2b useless symbols now Doesn’t remove any useful symbol in either step (Why?) Only remains to show how to do the two steps in this algorithm Generating and Reachable Symbols Generating symbols • If A → x, where x ∈ Σ∗, is a production then A is generating • If A → γ is a production and all variables in γ are generating, then A is generating. 5 Reachable symbols • S is reachable • If A is reachable and A → αBβ is a production, then B is reachable 1.4 Putting Together the Three Simpliﬁcations The Three Simpliﬁcations, Together Proposition 7. Given a grammar G, such that L(G) ̸= ∅, we can ﬁnd a grammar G′ such that L(G′) = L(G) and G′ has no ϵ-productions (except possibly S → ϵ), unit productions, or useless symbols, and S does not appear in the RHS of any rule. Proof. Apply the following 3 steps in order: 1. Eliminate ϵ-productions 2. Eliminate unit productions 3. Eliminate useless symbols. Note: Applying the steps in a diﬀerent order may result in a grammar not having all the desired properties. 2 Chomsky Normal Form Normal Forms for Grammars It is typically easier to work with a context free language if given a CFG in a normal form. Normal Forms A grammar is in a normal form if its production rules have a special structure: • Chomsky Normal Form: Productions are of the form A → BC or A → a, where A, B, C are variables and a is a terminal symbol. • Greibach Normal Form Productions are of the form A → aα, where α ∈ V ∗ and A ∈ V . If ϵ is in the language, we allow the rule S → ϵ. We will require that S does not appear on the right hand side of any rules. We will restrict our discussion to Chomsky Normal Form. Main Result Proposition 8. For any non-empty context-free language L, there is a grammar G, such that L(G) = L and each rule in G is of the form 6 1. A → a where a ∈ Σ, or 2. A → BC where neither B nor C is the start symbol, or 3. S → ϵ where S is the start symbol (iﬀ ϵ ∈ L) Furthermore, G has no useless symbols. Outline of Normalization Given G = (V, Σ, S, P ), convert to CNF • Let G′ = (V ′, Σ, S, P ′) be the grammar obtained after eliminating ϵ-productions, unit pro- ductions, and useless symbols from G. • If A → x is a rule of G′, where |x| = 0, then A must be S (because G′ has no other ϵ- productions). If A → x is a rule of G′, where |x| = 1, then x ∈ Σ (because G′ has no unit productions). In either case A → x is in a valid form. • All remaining productions are of form A → X1X2 · · · Xn where Xi ∈ V ′ ∪ Σ, n ≥ 2 (and S does not occur in the RHS). We will put these rules in the right form by applying the following two transformations: 1. Make the RHS consist only of variables 2. Make the RHS be of length 2. Make the RHS consist only of variables Let A → X1X2 · · · Xn, with Xi being either a variable or a terminal. We want rules where all the Xi are variables. Example 9. Consider A → BbCdef G. How do you remove the terminals? For each a, b, c . . . ∈ Σ add variables Xa, Xb, Xc, . . . with productions Xa → a, Xb → b, . . .. Then replace the production A → BbCdef G by A → BXbCXdXeXf G For every a ∈ Σ 1. Add a new variable Xa 2. In every rule, if a occurs in the RHS, replace it by Xa 3. Add a new rule Xa → a Make the RHS be of length 2 • Now all productions are of the form A → a or A → B1B2 · · · Bn, where n ≥ 2 and each Bi is a variable. 7 • How do you eliminate rules of the form A → B1B2 . . . Bn where n > 2? • Replace the rule by the following set of rules A → B1B(2,n) B(2,n) → B2B(3,n) B(3,n) → B3B(4,n) ... B(n−1,n) → Bn−1Bn where B(i,n) are “new” variables. An Example Example 10. Convert: S → aA|bB|b, A → Baa|ba, B → bAAb|ab, into Chomsky Normal Form. 1. Eliminate ϵ-productions, unit productions, and useless symbols. This grammar is already in the right form. 2. Remove terminals from the RHS of long rules. New grammar is: Xa → a, Xb → b, S → XaA|XbB|b, A → BXaXa|XbXa, and B → XbAAXb|XaXb 3. Reduce the RHS of rules to be of length at most two. New grammar replaces A → BXaXa by rules A → BXaa, Xaa → XaXa, and B → XbAAXb by rules B → XbXAAb, XAAb → AXAb, XAb → AXb 8","libVersion":"0.3.2","langs":""}