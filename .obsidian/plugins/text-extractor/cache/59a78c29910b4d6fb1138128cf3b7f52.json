{"path":"docs/学校课程/课程/编译原理/课件/Chapter_9.pdf","text":"许畅 南京大学计算机系 2024年春季 第九章 机器无关的优化 版权所有 南京大学计算机科学与技术系 许畅 2024春季版 主要内容 • 引言 • 优化的来源 • 数据流分析 • 部分冗余消除 • 循环的识别、分析和优化 2 引言 • 代码优化或者代码改进 – 在目标代码中消除不必要的指令 – 把一个指令序列替换为一个完成相同功能的更快的指 令序列 • 全局优化 – 具体的优化实现基于数据流分析技术 – 用以收集程序相关信息的算法 3 优化的主要来源 • 编译器只能通过一些相对低层的语义等价转换来 优化代码 – 冗余运算的原因 • 源程序中的冗余 • 高级程序设计语言编程的副产品，如A[i][j].f = 0; A[i][j].k = 1; – 语义不变的优化 • 公共子表达式消除 • 复制传播 • 死代码消除 • 常量折叠 4 优化的例子 (1) • 快速排序算法 5 优化的例子 (2) • 三地址代码 6 • 循环 – B2 – B3 – B2, B3, B4, B5 7 流图全局公共子表达式 • 如果E – 在某次出现之前必然已被计 算过，且 – E的运算分量在该次计算之 后没有被改变 – 那么，E的本次出现就是一 个公共子表达式 (common subexpression) • 如果上次E值赋给了x，且x 值没有被修改过，那么我 们可使用x，而无需计算E 8 例子： t7 = 4 * i t10 = 4 * j 不需要重新计算 t7 => t6 t10 => t8 9 例子 t6, t7 => t2 t8, t10 => t4 – B2, B3中计算了4 * i, 4 * j，且到达B5之前必然 经过B2, B3 – t2, t4在赋值后没有被 改变过，因此B5中可 直接使用它们 – B5中赋给x的值 (a[t6]) 和B2中赋给t3的值 (a[t2]) 相同 – t4替换t8后，B5中a[t8] 和B3中a[t4]又相同 – B6中的a[t13]和B1中的 a[t1]不同，因为B5可 能改变a的值 10 消除以后复制传播 • 形如u = v的复制语句 (copy statement) 使得语句后面的程序 点上，u的值等于v的值 – 如果在某个位置上u一定等于v，那 么可以把u替换为v – 有时可以彻底消除对u的使用，从 而消除对u的赋值语句 • 消除公共子表达式时引入了复制 语句；如果尽可能用t来替换c， 可能就不需要c = t这个语句了 11 例子 • 右图显示了对B5进行复制传播处理的情况 – 可能消除所有对x的使用 12 死代码消除 • 如果一个变量在某个程序点上的值可能会在之后 被使用，那么这个变量在这个点上活跃 (live)；否 则这个变量就是死的 (dead)，此时对该变量的赋 值就是没有用的死代码 • 死代码多半是因为前面的优化而形成的 • 比如，B5中的x = t3就是死代码 • 消除后得到 13 a[t2] = t5 a[t4] = t3 goto B2 x = t3 a[t2] = t5 a[t4] = t3 goto B2 ➔ 代码移动 • 循环中的代码会被执行很多次 – 循环不变表达式：循环的同一次运行的不同迭代中， 表达式的值不变 • 代码移动 (code motion)：把循环不变表达式移动 到循环入口之前计算可以提高效率 – 循环入口：进入循环的跳转都以这个入口为目标 • while (i <= limit – 2) … – 如果循环体不改变limit的值，可在循环外计算limit – 2 t = limit – 2 while (i <= t) … 14 归纳变量和强度消减 • 归纳变量 – 每次对x赋值都使x增加c – 可把赋值改为增量操作， 实现强度消减 (strength reduction) – 如果两个归纳变量步调 一致，可删除一个 – 例子 • 循环开始保持t4 = 4 * j • j = j – 1后面的t4 = 4 * j每 次赋值使t4减4 • 可替换为t4 = t4 – 4 15 数据流分析 • 数据流分析 – 用于获取数据沿着程序执行路径流动信息的相关技术 – 是优化的基础 • 例如 – 两个表达式是否一定计算得到相同的值？(公共子表达 式) – 一个语句的计算结果是否可能被后续语句使用？(死代 码消除) 16 数据流抽象 (1) • 程序点 – 三地址语句之前或之后的位置 – 基本块内部：一个语句之后的程序点等于下一个语句 之前的程序点 – 如果流图中有B1到B2的边，那么B2的第一个语句之前的 点可能紧跟在B1的最后语句之后的点后面执行 • 从p1到pn的执行路径 (execution path)：p1, …, pn – 要么pi是一个语句之前的点，且pi+1是该语句之后的点 – 要么pi是某个基本块的结尾，且pi+1是该基本块的某个 后继的开头 17 数据流抽象 (2) • 出现在某个程序点的程序状态 – 在某个运行时刻，当指令指针指向这个程序点时，各 个变量和动态内存中存放的值 – 指令指针可能多次指向同一个程序点，因此一个程序 点可能对应多个程序状态 • 数据流分析把可能出现在某个程序点上的程序状 态集合总结为一些特性 – 不管程序怎么运行，当它到达某个程序点时，程序状 态总是满足分析得到的特性 – 不同的分析技术关心不同的信息 18 例子 • 路径 – 1, 2, 3, 4, 9 – 1, 2, 3, 4, 5, 6, 7, 8, 3, 4, 9 • 第一次到达(5)，a = 1 • 第二次到达(5)，a = 243 – 之后都是243 • 我们可以说 – (5)具有特性a = 1或a = 243 – 表示成为<a, {1, 243}> 19 性质和算法 • 根据不同的需要来设置不同的性质集合，然后设 计分析算法 – 程序点上的性质被表示成为数据流值，求解这些数据 流值实际上就是推导这些性质的过程 • 例子 – 如果要求出变量在某个点上的值可能在哪里定值，可 以使用到达定值 (reaching definition) • 性质形式：x由d1定值 – 如果希望实现常量折叠优化，我们关心的是某个点上 变量x的值是否总是由某个常量赋值语句赋予 • 性质形式：x = c，以及x = NAC 20 数据流分析模式 • 数据流分析中，程序点和数据流值 (data-flow value) 关联起来 – 数据流值表示了程序点具有的性质 – 和某个程序点关联的数据流值：程序运行中经过这个 点时必然满足的条件 (安全) • 域 (domain) – 某个数据流所有可能值的集合称为该数据流值的域 – 不同的应用选用不同的域，比如到达定值 • 目标是分析在某个点上，各个变量的值由哪些语句定值 • 因此其数据流值是定值 (即三地址语句) 的集合 21 数据流分析 • 对一组约束求解，得到各个点上的数据流值 – 两类约束：基于语句语义和基于控制流 • 基于语句语义的约束 – 一个语句之前和之后的数据流值受到其语义的约束 – 语句语义通常用传递函数 (transfer function) 表示，它 把一个数据流值映射为另一个数据流值 • OUT[s] = fs(IN[s]) // 正向 IN[s] = fs(OUT[s]) // 逆向 • 基于控制流的约束 – 在基本块内部，一个语句的输出 = 下一语句的输入 – 流图的控制流边也对应新的约束 22 例子 • 考虑各个变量在某个程序点上是否为常量 – s是语句x = 3 – 考虑变量x, y, z – 如果IN[s]： x: NAC; y: 7; z: 3 – 那么OUT[s]： x: 3; y: 7; z: 3 • 如果 – s是x = y + z，那么OUT[s]是？ – s是x = x + y，那么OUT[s]是？ 23 基本块内的数据流模式 • 基本块内的控制流非常简单 – 从头到尾不会中断 – 没有分支 • 基本块的效果就是各个语句的效果的复合 • 可以预先处理基本块内部的数据流关系，给出基 本块对应的传递函数 – OUT[B] = fB(IN[B]) 或 IN[B] = fB(OUT[B]) • 设基本块包含语句s1, s2, …, sn – fB = fsn ◦ … ◦ fs2 ◦ fs1 24 基本块之间的控制流约束 • 前向数据流问题 – B的传递函数根据IN[B]计算 得到OUT[B] – IN[B]和B的各前驱基本块的 OUT值之间具有约束关系 • 逆向数据流问题 – B的传递函数根据OUT[B]计 算得到IN[B] – OUT[B]和B的各后继基本块 的IN值之间具有约束关系 25 B1 B3 B B2 前向数据流的例子 假如 OUT[B1]：x: 3; y: 4; z: NAC OUT[B2]：x: 3; y: 5; z: 7 OUT[B3]：x: 3; y: 4; z: 7 则 IN[B]：x: 3; y: NAC; z: NAC 数据流方程解的精确性和安全性 • 数据流方程通常没有唯一解 • 目标是寻找一个最“精确”且满足约束的解 – 精确：能够进行更多的改进 – 满足约束：根据分析结果来改进代码是安全的 26 到达定值 (1) • 到达定值 – 假定x有定值d，如果存在一个路径，从紧随d的点到达 某点p，并且此路径上面没有x的其它定值点，则称x的 定值d到达p – 如果在这条路径上有对x的其它定值，我们说变量x的 这个定值d被杀死了 • 如果某个变量x的一个定值d到达了点p，在p点使 用变量x的时候，x的值是由d最后定值的 27 到达定值 (2) • 到达定值的解允许不精确，但必须是安全的 – 分析得到的到达定值可能实际上不会到达 – 但是实际到达的一定被分析出来，否则不安全 • 比如确定x在p点是否为常量 – 忽略实际的到达定值使得变化的值被误认为常量，将 这些值替换为常量会引起错误，不安全 – 过多估计则相反 28 • B1全部定值到达B2的开头 • d5到达B2的开头 (循环) • d2被d5杀死，不能到达B3、 B4的开头 • d4不能到达B2的开头，因 为被d7杀死 • d6到达B2的开头 29 例子语句/基本块的传递方程 (1) • 定值 d: u = v + w – 生成了对变量u的定值d，杀死其它对u的定值 – 生成-杀死形式：fd(x) = gend ∪ (x – killd) – gend = { d }，killd = { 程序中其它对u的定值 } • 生成-杀死形式的函数复合仍具有该形式 – f2(f1(x)) = gen2 ∪ (gen1 ∪ (x – kill1) – kill2) = (gen2 ∪ (gen1 – kill2)) ∪ (x – kill1 ∪ kill2)) – 生成的定值：由第二部分生成、以及由第一部分生成 且没有被第二部分杀死 – 杀死的定值：被第一部分杀死、以及被第二部分杀死 的定值 30 语句/基本块的传递方程 (2) • 设B有n个语句，第i个语句的传递函数为fi • fB(x) = genB ∪ (x – killB) – genB = genn ∪ (genn-1 – killn) ∪ … ∪ (gen1 – kill2 – kill3 – … – killn) – killB = kill1 ∪ kill2 ∪ … ∪ killn – genB是被第i个语句生成，且没有被其后的句子杀死的 定值的集合：向下可见 (downwards exposed) – killB为被B各个语句杀死的定值的并集 – 一个定值可能同时出现在两个集合中 31 gen和kill的例子 • 基本块 – d1: a = 3 – d2: a = 4 • gen集合：{ d2 } • kill集合：{ 流图中所有针对a的定值 } 32 到达定值的控制流方程 • 只要一个定值能够沿某条路径 到达一个程序点，这个定值就 是到达定值 • IN[B] = ∪P是B的前驱基本块OUT[P] – 如果从基本块P到B有一条控制流 边，那么OUT[P]在IN[B]中 – 一个定值必然先在某个前驱的 OUT值中，才能出现在B的IN中 • ∪称为到达定值的交汇运算 (meet operator) 33 P1 P3 B P2 d: x = y + z d d 此路径上 x不一定 被覆盖 控制流方程的迭代解法 (1) • ENTRY基本块的传递函数是常函数 – OUT[ENTRY] = 空集 • 其它基本块 – OUT[B] = genB ∪ (IN[B] – killB) // 基本块内部 – IN[B] = ∪P是B的前驱基本块OUT[P] // 基本块之间 • 迭代解法 – 首先求出各基本块的genB和killB – 令所有的OUT[B]都是空集，然后不停迭代，得到最小 不动点 (least fixedpoint) 的解 34 控制流方程的迭代解法 (2) • 输入：流图、各基本块的kill和gen集合 • 输出：IN[B]和OUT[B] • 方法 35 控制流方程的迭代解法 (3) • 解法的正确性 – 不断向前传递各个定值，直到该定值被杀死为止 • 为什么不会出现死循环？ – 各个OUT[B]在算法执行过程中不会变小 – 且OUT[B]显然有有穷的上界 – 只有一次迭代之后增大了某个OUT[B]的值，算法才会 进行下一次迭代 • 最大的迭代次数是流图的结点个数n – 定值经过n步必然已经到达所有可能到达的结点 • 结束时，各个OUT/IN值必然满足数据流方程 3637 到达定值求解的例子 – 7个bit从左到右表示d1, d2, …, d7 – for循环时依次遍历B1, B2, B3, B4, EXIT – 每一列表示一次迭代计算 – B1生成d1, d2, d3，杀死d4, d5, d6, d7 – B2生成d4, d5，杀死d1, d2, d7 – B3生成d6，杀死d3 – B4生成d7，杀死d1, d4 活跃变量分析 • 活跃变量分析 (live-variable analysis) – x在p上的值是否会在某条从p出发的路径中使用 – 变量x在p上活跃，当且仅当存在一条从p开始的路径， 该路径的末端使用了x，且路径上没有对x进行覆盖 • 用途 – 寄存器分配/死代码删除/… • 数据流值 – (活跃) 变量的集合 38 基本块内的数据流方程 • 基本块的传递函数仍然是生成-杀死形式，但是从 OUT值计算出IN值 (逆向) – useB：在B中先于定值被使用 – defB：在B中先于使用被定值 • 例子 – 基本块B2：i = i + 1; j = j – 1; • use = { i, j } • def = { } 39 useB和defB的用法 • 语句的传递函数 – s: x = y + z – uses = { y, z } – defs = { x } – { y, z } // y, z可能与x相同 • 假设基本块中包含语句s1, s2, …, sn，那么 – useB = use1 ∪ (use2 – def1) ∪ (use3 – def1 – def2) ∪ … ∪ (usen – def1 – def2 – … – defn-1) – defB = def1 ∪ (def2 – use1) ∪ (def3 – use1 – use2) ∪ … ∪ (defn – use1 – use2 – … – usen-1) 40 活跃变量数据流方程 • 任何变量在程序出口处不再活跃 – IN[EXIT] = 空集 • 对于所有不等于EXIT的基本块 – IN[B] = useB ∪ (OUT[B] – defB) // 基本块内部 – OUT[B] = ∪S是B的后继基本块IN[S] // 基本块之间 • 和到达定值相比较 – 都使用并集运算∪作为交汇运算 – 数据流值传递方向相反，因此初始化的值 (IN) 不一样 41 活跃变量分析的迭代方法 • 这个算法中IN[B]总是越来越大，且IN[B]都有上 界，因此必然会停机 42 可用表达式分析 • x + y在p点可用 (available) 的条件 – 从流图入口结点到达p的每条路径都对x + y求值，且在 最后一次求值之后再没有对x或y赋值 • 主要用途 – 寻找全局公共子表达式 • 生成-杀死 – 生成：基本块求值x + y，且之后没有对x或y赋值，那 么它生成了x + y – 杀死：基本块对x或y赋值，且没有重新计算x + y，那 么它杀死了x + y 43 计算基本块生成的表达式 • 初始化S = { } • 从头到尾逐个处理基本块中的指令x = y + z – 把y + z添加到S中 – 从S中删除任何涉及变量x的表达式 • 遍历结束时得到基本块生成的表达式集合 • 杀死的表达式集合 – 表达式的某个分量在基本块中被定值，并且该表达式 没有被再次生成 44 基本块生成/杀死的表达式的例子 45 可用表达式的数据流方程 • ENTRY结点的出口处没有可用表达式 – OUT[ENTRY] = 空集 • 其它基本块的方程 – OUT[B] = e_genB ∪ (IN[B] – e_killB) // 基本块内部 – IN[B] = ∩P是B的前驱基本块OUT[P] // 基本块之间 • 和其它方程类比 – 前向传播 – 交汇运算是交集运算 46 可用表达式分析的迭代方法 • 注意：OUT值的初始化值是全集 47 三种数据流方程的总结 48 数据流分析的理论基础 • 问题 – 数据流分析中的迭代算法在什么情况下正确？ – 得到的解有多精确？ – 迭代算法是否收敛？ – 方程组的解的含义是什么？ • 通过定义一个数据流分析框架，利用离散数学中 半格、偏序等概念和性质，给出数据流分析算法 的理论依据 49 部分冗余消除 • 目标：尽量减少表达式求值的次数 • 对于表达式x + y – 全局公共子表达式：如果对x + y求值前的程序点上x + y可用，那么不需要再对x + y求值 – 循环不变表达式：循环中的表达式x + y的值不变，可 以只计算一次 – 部分冗余：在程序按照某些路径到达这个点的时候x + y已经被计算过，但沿着另外一些路径到达时，x + y尚 未计算过 • 需要更复杂的数据流分析技术 50 例子 51 需要添加基本块来消除的冗余 • 进行两种操作 – 在关键边上增 加基本块 – 进行代码复制 • 关键边 – 从具有多个后 继的结点到达 具有多个前驱 的结点 52 a  t 懒惰代码移动 • 目标 – 所有不复制代码就可消除的冗余计算都被消除 – 优化后的代码不会执行原程序中不执行的任何计算 – 表达式的计算应该尽量靠后，以利于寄存器的分配 • 冗余消除 – 完全冗余 – 部分冗余：在流图中放置表达式x + y的拷贝，使得某 处的x + y成为完全冗余，从而删除 53 基本步骤 • 按照如下四个步骤进行处理 – 1. 找出各程序点上预期执行的所有表达式 – 2. 在表达式被预期执行但是不可用的程序点上，放置 表达式的计算 – 3. 把表达式尽量后延到某个程序点，在到达这个点的 所有路径上，这个表达式在这个程序点之前被预期执 行，但是还没有使用这个值 – 4. 消除只使用一次的临时变量 54 1. 预期执行表达式 (1) • 预期执行 (anticipated) – 如果从程序点p出发的所有 路径都会计算表达式b + c 的值，并且b和c在那时的 值就是它们在点p的值，那 么表达式b + c在点p上被预 期执行 • 例子 – 表达式b + c在B3、B4、B5、 B6、B7和B9的入口处被预期 执行 55 1. 预期执行表达式 (2) • 数据流分析框架 – 逆向分析 – 基本块内部：当表达式在B出口处被预期执行，且它没 有被B杀死，那么它在B入口处也被预期执行 – 基本块之间：当在B的所有后继基本块的入口处都被预 期执行，那么表达式在B出口处被预期执行 – 在整个程序的出口处，没有表达式被预期执行 • 求出预期执行点之后，表达式被放置到首次被预 期执行的程序点上 – 此时一些表达式变得完全冗余 56 2. 可用表达式 • 和前面的可用表达式类似，但假设代码已经被复 制到了预期执行点上 • 表达式在基本块的出口处可用 (available) 的条件 – 在基本块的入口处可用，或在基本块的入口处的预期 执行表达式中 – 且没有被这个基本块杀死 57 2. 例子 • 表达式b + c在B1、B2、 B3和B5不可用 58 3. 可后延表达式 (1) • 在保持程序语义的情况下， 尽可能延后计算表达式 • x + y可后延 (postponable) 到p的条件 – 所有从程序入口到达p的路径 中都会碰到一个位置较前的x + y，且在最后一个这样的位 置到p之间没有使用x + y • 右边的例子 – b + c在B1被预期执行 – b + c可后延到B4 → B7的边上 59 3. 可后延表达式 (2) • 粗略地说，一个表达式将被放置在边界上，即一 个表达式从可后延变成不可后延的地方 60 3. 例子 • 可放置b + c的两个最早 的点是B3和B5 – 不能从B5后延到B6 – 但可以从B3后延到B4 61 4. 被使用的表达式 • 确定一个被引入的临时变量是否在它所在基本块 之外的其它地方被使用 (used) – 对表达式的活跃性分析 – 如果从程序点p出发的一条路径在表达式被重新求值之 前使用了该表达式，那么该表达式在点p上被使用 6263 流图中的循环 • 循环的重要性 – 程序的大部分执行时间都花在循环上 – 也是数据流分析需要经过若干次迭代的原因 • 相关概念 – 支配结点 – 深度优先排序 – 回边 – 图的深度 – 可归约性 65 支配结点 • 支配 (dominate) – 如果每条从入口结点到达n的路径都 经过d，那么d支配n，记为d dom n – 例子 • 1支配所有结点 • 2只支配自己 • 3支配除了1、2外的其它结点 • 4支配1、2、3外的其它结点 • 5、6只支配自身 • 7支配7、8、9、10 • 8支配8、9、10 • 9、10只支配自身 66 支配结点树 (1) • 支配结点树 (dominator tree) 可以表示支配关系 – 根结点：入口结点 – 每个结点d支配且只支配树中的后代结点 • 直接支配结点 (immediate dominator) – 从入口结点到达n的任何路径 (不含n) 中，它是路径中 最后一个支配n的结点 – 前面的例子：1直接支配3，3直接支配4 – n的直接支配结点m具有如下性质：如果d  n且d dom n，那么d dom m 67 支配结点树 (2) • 例子 68 寻找支配结点算法 (1) • 计算流图中各个结点n的所有支配结点 – p1, p2, …, pk是n的所有前驱且d ≠ n，那么d dom n当且 仅当d dom pi (1  i  k) • 一个结点的支配结点集合 (它自己除外) 是它的所 有前驱的支配结点集合的交集 • 前向数据流分析问题 69 寻找支配结点算法 (2) • 求解如图所示的数 据流方程组，可以 得到各结点对应的 支配结点集合 • D(n) = OUT[n] 70 例子 71 D(1) = {1} = {1, 2} 深度优先生成树 • 深度优先搜索 (depth-first search) – 搜索过程从入口结点开始，并首先访问离入口结点最 远的结点 • 深度优先生成树 – 一个深度优先过程中的搜索路线形成了一个深度优先 生成树 (depth-first spanning tree, DFST) 72 例子 • 左边：流图，右边：深度优先生成树 – 实线边形成了这棵树，虚线边是流图中其它的边 – 深度优先搜索：1-3-4-6-7-8-10-8-9-8-7-…… 73 深度优先排序 • 前序遍历 – 先访问一个结点，然后从左到右递归地访问该结点的 子结点 • 后序遍历 – 首先递归地从左到右访问一个结点的子结点，然后访 问该结点 • 深度优先排序 (depth-first ordering) – 首先访问一个结点，然后访问该结点的最右子结点， 再访问这个子结点左边的子结点，依次类推 (与后序遍 历的顺序相反) 74 例子 • 前序遍历：1, 3, 4, 6, 7, 8, 10, 9, 5, 2 • 后序遍历：10, 9, 8, 7, 6, 5, 4, 3, 2, 1 • 深度优先排序：1, 2, 3, 4, 5, 6, 7, 8, 9, 10 75 深度优先生成树和深度优先排序算法 • T中记录了深度优先生 成树的边集合 • dfn[n]表示n的深度优 先编号 • c的值从n逐步递减到1 76 流图中边的分类 • 为一个流图构造出DFST之后，流图中的边可以分 为三类 – 前进边 (advancing edge)：从结点m到达m在DFST树 中的一个真后代结点的边 (DFST中的所有边都是前进 边) – 后退边 (retreating edge)：从m到达m在DFST树中的某 个祖先 (包括m) 的边 – 交叉边 (cross edge)：边的src和dest都不是对方的祖先 – 考虑：3 → 4, 10 → 7, 5 → 7 77 回边和可归约性 (1) • 回边 – 边a → b，头b支配了尾a – 每条回边都是后退边，但不是所有后退边都是回边 • 如果一个流图的任何深度优先生成树中的所有后 退边都是回边，那么该流图就是可归约的 (reducible) – 可归约流图的DFST的后退边集合就是回边集合 – 不可归约流图的DFST中可能有一些后退边不是回边 78 回边和可归约性 (2) • 现实中出现的流图基本都是可归约的 – 可归约的例子 – 不可归约的例子 (无回边) 79 流图的深度 • 流图相对于DFST的深度 – 各条无环路径上后退边数 中的最大值 – 不会大于直观上所说的流 图中的循环嵌套深度 • 对可归约的流图，可使 用回边来定义，且可说 是流图的深度 (depth) • 右边的流图深度为3 – 10 → 7 → 4 → 3 80 自然循环 • 自然循环的性质 – 有一个唯一的入口结点，即循环头 (header)，这个结 点支配循环中的所有结点 – 必然存在进入循环头的回边 • 自然循环 (natural loop) 的定义 – 给定回边n → d的自然循环是d，加上不经过d就能够到 达n的结点的集合 – d是这个循环的头 81 自然循环构造算法 • 输入：流图G和回边n → d • 输出：给定回边n → d的自然循环中的所有结点的 集合loop • 方法 – loop = { n, d }，d标记为visited – 从n开始，逆向对流图进行深度优先搜索，把所有访问 到的结点都加入loop，加入loop的结点都标记为visited – 搜索过程中，不越过标记为visited的结点 82 自然循环的例子 • 回边：10 → 7 – { 7, 8, 10 } • 回边：7 → 4 – { 4, 5, 6, 7, 8, 10 } – 包含了前面的循环 • 回边4 → 3 (8 → 3) – 同样的头 – 同样的结点集合{ 3, 4, 5, 6, 7, 8, 10 } • 回边9 → 1 – 整个流图 83 自然循环的性质 • 除非两个循环具有同样的循环头，它们 – 要么是分离的 – 要么一个嵌套于另一个中 • 最内层循环 (inner-most loop) – 不包含其它循环的循环 – 通常是最需要进行优化的地方 84","libVersion":"0.3.2","langs":""}