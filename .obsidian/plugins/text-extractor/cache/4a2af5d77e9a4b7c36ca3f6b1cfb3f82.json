{"path":"docs/学校课程/归档课程/编译原理/课件/Chapter_4.pdf","text":"许畅 南京大学计算机系 2024年春季 第四章 语法分析 版权所有 南京大学计算机科学与技术系 许畅 2024春季版 概要 • 语法分析器 • 上下文无关文法 • 语法分析技术 – 自顶向下 – 自底向上 • 语法分析器生成工具 2 语法分析器的作用 • 基本作用 – 从词法分析器获得词法单元的序列，确认该序列是否 可以由语言的文法生成 – 对于语法错误的程序，报告错误信息 – 对于语法正确的程序，生成语法分析树 (简称语法树) • 通常并不真的产生这棵语法分析树 3 语法分析器的分类 • 通用语法分析器 – 可以对任意文法进行语法分析 – 效率很低，不适合用于编译器 • 自顶向下语法分析器 (通常用于处理LL文法) – 从语法分析树的根部开始构造语法分析树 • 自底向上语法分析器 (通常用于处理LR文法) – 从语法分析树的叶子开始构造语法分析树 • 后两种方法 – 总是从左到右、逐个扫描词法单元 – 只能处理特定类型的文法，但足以描述程序设计语言 4 程序设计语言构造的描述 • 程序设计语言构造的语法可使用上下文无关文法 (CFG) 或BNF表示法来描述 – 文法可给出精确易懂的语法规则 – 可以自动构造出某些类型的文法的语法分析器 – 文法指出了语言的结构，有助于进一步的语义处理/代 码生成 – 支持语言的演化和迭代 5 上下文无关文法 • 一个上下文无关文法 (CFG) 包含四个部分 – 终结符号：组成串的基本符号 (词法单元名字) – 非终结符号：表示串的集合的语法变量 • 在程序设计语言中通常对应于某个程序构造，比如stmt (语句) – 开始符号：某个被指定的非终结符号 • 它对应的串的集合就是文法的语言 – 产生式：描述将终结符号和非终结符号组成串的方法 • 形式：头 (左) 部 → 体 (右) 部 • 头部是一个非终结符号，右部是一个符号串 • 例子：expression → expression + term 6 上下文无关文法的例子 • 简单算术表达式的文法 – 终结符号：id, +, –, *, /, (, ) – 非终结符号：expression, term, factor – 开始符号：expression – 产生式集合 expression → expression + term expression → expression – term expression → term term → term * factor term → term / factor term → factor factor → ( expression ) factor → id 7 文法简单形式的例子 E → E + T | E – T | T T → T * F | T / F | F F → ( E ) | id • 注意 – |是元符号 (即文法描述中的符号，而不是文法符号) – 这里的 ( 和 ) 不是元符号 9 推导 (1) • 推导 – 将待处理的串中的某个非终结符号替换为这个非终结 符号的某个产生式的体 – 从开始符号出发，不断进行上面的替换，就可以得到 文法的不同句型 • 例子 – 文法：E → – E | E + E | E * E | ( E ) | id – 推导序列：E => – E => – ( E ) => – ( id ) 10 推导 (2) • 推导的正式定义 – 如果A → γ是一个产生式，那么αAβ => αγβ – 最左/右推导 (leftmost/rightmost derivation)：α/β中不 包含非终结符号 • 符号： • 经过零步或者多步推导出： – 对于任何串α α – 如果α β且β => γ，那么α γ • 经过一步或者多步推导出： – α β即α β且α不等于β (不严格) 11 句型/句子/语言 • 句型 (sentential form) – 如果S α，那么α就是文法S的句型 – 可能既包含非终结符号，又包含终结符号，也可以是 空串 • 句子 (sentence) – 文法的句子就是不包含非终结符号的句型 • 语言 – 文法G的语言就是G的句子的集合，记为L(G) – w在L(G)中当且仅当w是G的句子，即S w 12 语法分析树 • 推导的图形表示形式 – 根结点的标号是文法的开始符号 – 每个叶子结点的标号是非终结符号、终结符号或ε – 每个内部结点的标号是非终结符号 – 每个内部结点表示某个产生式的一次应用 • 结点的标号为产生式头，其子结点从左到右是产生式的体 • 树的叶子组成的序列是根的文法符号的一个句型 • 一棵语法分析树可对应多个推导序列 – 但只有唯一的最左推导及最右推导 13 例子 • 文法：E → – E | E + E | E * E | ( E ) | id • 句子：– ( id + id ) 14 从推导序列构造分析树 • 假设有推导序列 – A = a1 => a2 => … => an • 算法 – 初始化：a1的分析树是标号为A的单个结点 – 假设已经构造出ai-1 = X1X2…Xk的分析树，且ai-1到ai的 推导是将Xj替换为β，那么在当前分析树中找出第j个非 ε结点，向这个结点增加构成β的子结点；如果β = ε， 则增加一个标号为ε的子结点 15 例子 • 推导序列 – E => – E => – ( E ) => – ( E + E ) => – ( id + E ) => – ( id + id ) 16 二义性 (1) • 二义性 (ambiguity)：如果一个文法可以为某个句 子生成多棵语法分析树，这个文法就是二义的 • 例子 – E => E + E => id + E => id + E * E => id + id * E => id + id * id – E => E * E => E + E * E => id + E * E => id + id * E => id + id * id 17 都是最左推导 二义性 (2) • 程序设计语言的文法通常是无二义的 – 否则就会导致一个程序有多种“正确”的解释 – 如文法 E → – E | E + E | E * E | ( E ) | id 应对句子 a + b * c 时 • 有些二义性的情况可以方便文法或语法分析器的 设计 (后面介绍) – 但需要消二义性规则来剔除不要的语法分析树 – 比如：先乘除后加减 18 词法分析和语法分析的比较 阶段 输入 输出 描述体系 词法分析 源程序符号串 词法单元序列 正则表达式 语法分析 词法单元序列 语法分析树 上下文无关文法 19 上下文无关文法和正则表达式 (1) • 上下文无关文法比正则表达式的能力更强 – 所有的正则语言都可以使用文法描述 – 但有一些用文法描述的语言不能用正则表达式描述 • 证明 – 首先S → aSb | ab描述了语言L { anbn | n > 0 }，但这个 语言无法用DFA识别 • 假设有DFA识别此语言L，且这个DFA有k个状态。那么在识 别ak+1…的输入串时，必然两次到达同一个状态。假设自动机 在第i个和第j个a时进入同一个状态，那么：因为DFA识别L， ajbj必然到达接受状态，因此aibj必然也到达接受状态。 • 直观地讲：有穷自动机不能计数 20 上下文无关文法和正则表达式 (2) • 证明 (续) – 任何正则语言都可以表示为上下文无关文法的语言 – 任何正则语言都必然有一个NFA，对于该NFA构造如 下的上下文无关文法 • 对NFA的每个状态i，创建非终结符号Ai • 如果有i在输入a上到达j的转换，增加产生式Ai → aAj • 如果i在输入ε上到达j，那么增加产生式Ai → Aj • 如果i是一个接受状态，增加产生式Ai → ε • 如果i是开始状态，令Ai为所得文法的开始符号 21 NFA构造文法的例子 • A0 → aA0 | bA0 | aA1 • A1 → bA2 • A2 → bA3 • A3 → ε – 考虑baabb的推导和接受过程可知：NFA接受一个句子 的运行过程实际就是该文法推导出该句子的过程 22 (a|b)*abbb 文法及其生成的语言 • 语言是从文法的开始符号出发，能推导得到的所 有句子的集合 – 文法G：S → aS | a | b，L(G) = { ai(a|b), i >= 0 } – 文法G：S → aSb | ab，L(G) = { anbn, n >= 1 } – 文法G：S → (S)S | ε，L(G) = { 所有具有对称括号对的 串 } • 如何验证文法G所确定的语言L – 证明G生成的每个串都在L中 – 证明L中的每个串都能被G生成 23 设计文法 (1) • 文法能够描述程序设计语言的大部分语法 – 但不是全部，比如，标识符的先声明后使用则无法用 上下文无关文法描述 – 因此语法分析器接受的语言是程序设计语言的超集； 必须通过语义分析来剔除一些符合文法、但不合法的 程序 24 设计文法 (2) • 在进行高效的语法分析之前，需要对文法做以下 处理 – 消除二义性 • 二义性：文法可以为一个句子生成多颗不同的分析树 – 消除左递归 • 左递归：文法中一个非终结符号A使得对某个串α，存在一个 推导 A Aα，则称这个文法是左递归的 – 提取左公因子 25 二义性的消除 (1) • 一些二义性文法可被改成等价的无二义性的文法 • 例子 stmt → if expr then stmt | if expr then stmt else stmt | other – if E1 then if E2 then S1 else S2的两棵语法树 26 二义性的消除 (2) • 保证else和最近未匹配的then匹配 – 要求在then和else之间出现的语句必须是匹配好的 • 引入matched_stmt表示匹配好的语句 stmt → matched_stmt | open_stmt matched_stmt → if expr then matched_stmt else matched_stmt | other open_stmt → if expr then stmt | if expr then matched_stmt else open_stmt • 二义性的消除方法没有规律可循 27 左递归的消除 • 左递归 (left recursive) 的定义 – 如果一个文法中有非终结符号A使得A Aα，那么这 个文法就是左递归的 • 立即左递归 – 文法中存在一个形如A → Aα的产生式 • 自顶向下的语法分析技术不能处理左递归的情况， 因此需要消除左递归，但是自底向上的技术可以 处理左递归 28 立即左递归的消除 • 假设非终结符号A存在立即左递归 的情形 A → Aα1 | … | Aαm | β1 | … | βn • 可替换为 A → β1A' | … | βnA' A' → α1A' | … | αmA' | ε • 观察：由A生成的串以某个βi开头， 然后跟上零个或多个αj 29 A → Aα | β A → βA' A' → αA' | ε A' A' A' A' 例子 30 消除多步左递归 • 消除立即左递归的方法并不能消除因为多步推导 而产生的左递归 – 文法：S → Aa | b A → Ac | Sd | ε – S => Aa => Sda • 如何消除？ 31 通用的左递归消除方法 • 输入：没有环和ε产生式的文法G • 输出：等价的无左递归的文法 • 步骤 将文法的非终结符号排序为A1, A2, …, An for i = 1 to n do { for j = 1 to i – 1 do { 将形如Ai → Ajγ的产生式替换为Ai → δ1γ | δ2γ | … | δkγ， 其中Aj → δ1 | δ2 | … | δk是以Aj为左部的所有产生式 } 消除Ai的立即左递归 } 32 通用的左递归消除的例子 • S → Aa | b A → Ac | Sd | ε 排列为S, A • i = 1时：内层循环不运行，S没有立即左递归 • i = 2时：j = 1，处理规则A → Sd，替换得到 – A → Ac | Aad | bd | ε • 消除A的立即左递归 – S → Aa | b – A → bdA' | A' – A' → cA' | adA' | ε • 通用左递归消除的问题在于很难找到新文法和旧 文法推导之间的对应关系，很难进行语义处理 33 本例子中的ε产生式恰好没 影响算法的正确性 预测分析法简介 • 试图从开始符号推导出输入符号串 • 每次为最左边的非终结符号选择适当的产生式 – 通过查看下一个输入符号来选择这个产生式 – 有多个可能的产生式时则无能为力 • 文法：E → + E E | – E E | id，输入：+ id – id id • 当两个产生式具有相同前缀时无法预测 – 旧文法：stmt → if expr then stmt else stmt – | if expr then stmt – 新文法：stmt → if expr then stmt elsePart – elsePart → else stmt | ε 34 需提取左公因子 考虑 if a then … 提取公因子的文法变换 • 算法 – 输入：文法G – 输出：等价的提取了左公因子的文法 – 方法：对于每个非终结符号A，找出它的两个或者多个 可选产生式体之间的最长公共前缀 • A → αβ1 | … | αβn | γ • A → αA' | γ A' → β1 | … | βn • 其中γ是不以α开头的产生式体 35 例子 • 文法 – S → i E t S e S | i E t S | a – E → b • 对于S而言，最长的前缀是i E t S，因此 – S → i E t S S' | a – S' → e S | ε – E → b 36 自顶向下的语法分析 • 为输入串构造语法分析树 – 从分析树的根结点开始，按照先根次序，深度优先地 创建各个结点 – 对应于最左推导 • 基本步骤 – 确定对句型中最左边的非终结符号应用哪个产生式 – 然后对该产生式与输入符号进行匹配 • 关键问题 – 确定对最左边的非终结符号应用哪个产生式 37 例子 • 文法 E → T E' E' → + T E' | ε T → F T' T' → * F T' | ε F → ( E ) | id • 输入 id + id * id • 分析树见右 38 递归下降的语法分析 • 每个非终结符号对应于一个过程，该过程负责扫 描此非终结符号对应的结构 • 程序执行从开始符号对应的过程开始 – 当扫描整个输入串时宣布分析成功完成 39 递归下降分析技术的回溯 • 如果没有足够的信息来唯一确定可能的产生式， 那么分析过程就产生回溯 – 算法报告错误 (第7行；第4行也可能返回错误) 并不意 味着输入串不是句子，也可能表示前面选错了产生式 – 在第1行保存当前的扫描指针，并把第7/4行改成 • 回退到保存的指针，并 GOTO 1) 去选择下一个产生式 • 如果没有下一个产生式可选，则报告错误 • 回溯需要来回扫描，甚至撤销已完成的语义动作 • 解决方法 (后面介绍) – 设法通过一些信息来确定唯一可能的产生式 40 递归下降分析中回溯的例子 • 文法：S → cAd A → ab | a；输入串：cad • 步骤 – 调用函数S，选择唯一的产生式S → cAd – 输入中的c与句型中的c匹配，继续调用函数A – A首先选择产生式A → ab，a与输入的a匹配，但b和输 入的d不匹配 – 回溯并选择下一个产生式A → a，a与输入的a相匹配， 对函数A的调用返回到S的调用 – S → cAd中最后的d与下一个输入d匹配，结束 • 因此cad是S的句子 41 FIRST和FOLLOW • 在自顶向下的分析技术中，使用向前看几个符号 来确定产生式 (通常只看一个符号) • 当前句型是xAβ，而输入是xa …，那么选择产生 式A → α的必要条件是下列之一 – α a … – α ε，且β以a开头，即在某个句型中a跟在A之后 – 如果按照这两个条件选择时能够保证唯一性，那么我 们就可以避免回溯 • 因此，我们定义FIRST和FOLLOW 42 FIRST • FIRST(α) – 可以从α推导得到串的首符号的集合 – 如果α ε，那么ε也在FIRST(α)中 • FIRST函数的意义 – A的产生式 A → α | β，且FIRST(α)和FIRST(β)不相交 – 下一个输入符号是a，若a ∈ FIRST(α)，则选择A → α ，若a ∈ FIRST(β)，则选择A → β 43 FIRST的计算方法 • 计算FIRST(X) – X是终结符号，那么加入X – X是非终结符号，且X → Y1Y2…Yk是产生式 • 如果a在FIRST(Yi)中，且ε在FIRST(Y1), … , FIRST(Yi-1)中，那 么也加入a • 如果ε在FIRST(Y1), … , FIRST(Yk)中，那么也加入ε – X是非终结符号且X → ε，那么也加入ε • 计算FIRST(X1X2…Xn) – 加入FIRST(X1)中所有非ε符号 – 若ε在FIRST(X1)中，加入FIRST(X2)中所有非ε符号 … – 若ε在所有FIRST(Xi)中，也加入ε 44 FOLLOW • FOLLOW(A) – 可能在某些句型中紧跟在A右边的终结符号的集合 – 例如：S → αAaβ，终结符号a ∈ FOLLOW(A) • FOLLOW函数的意义 – 如果A → α，当α → 或α => 时，FOLLOW(A)可以帮 助我们选择恰当的产生式 – 例如：A → α，而b属于FOLLOW(A)，如果α => ，而 当前输入符号是b，则可以选择A → α，因为A最终到 达了，而且后面跟着b 45 FOLLOW的计算方法 • 算法 – 将右端结束标记$加入FOLLOW(S)中 – 按照下面两个规则不断迭代，直到所有的FOLLOW集 合都不再增长为止 • 如果存在产生式A → αBβ，那么FIRST(β)中所有非ε的符号都 加入FOLLOW(B)中 • 如果存在一个产生式A → αB，或者A → αBβ且FIRST(β)包含ε， 那么FOLLOW(A)中所有符号都加入FOLLOW(B)中 46 例子 (1) • 文法 – E → TE' E' → + TE' | ε – T → FT' T' → * FT' | ε F → ( E ) | id • FIRST集合的计算 – FIRST(F) = { (, id } – FIRST(T) = FIRST(F) = { (, id } – FIRST(E) = FIRST(T) = { (, id } – FIRST(E') = { +, ε } FIRST(T') = { *, ε } • 由此可推出各个产生式右部的FIRST集合 – 如：FIRST(TE') = FIRST(T) = { (, id } 47 例子 (2) • FOLLOW集合的计算 – FOLLOW(E) = { $, ) } // E是开始符号 – FOLLOW(E') = { $, ) } // E → T E' – FOLLOW(T) = { +, $, ) } // E ' → + T E' – FOLLOW(T') = { +, $, ) } // T → F T' – FOLLOW(F) = { *, +, $, ) } // T → F T' 48 LL(1)文法 (1) • 定义：对文法的任意两个产生式A → α | β – 不存在终结符号a使得α和β都可推导出以a开头的串 – α和β最多只有一个可推导出空串 – 如果β可推导出空串，那么α不能推导出以FOLLOW(A) 中任何终结符号开头的串 • 等价于 – FIRST(α)  FIRST(β) = Φ (条件一、二) – 如果ε ∈ FIRST(β)，那么FIRST(α)  FOLLOW(A) = Φ； 反之亦然 (条件三) 49 LL(1)文法 (2) • 对于LL(1)文法，可以在自顶向下分析过程中，根 据当前输入符号来确定使用的产生式 – 产生式：stmt → if (exp) stmt else stmt | while (exp) stmt | a – 输入：if (exp) while (exp) a else a • 首先选择产生式stmt → if (exp) stmt else stmt 得到句型if (exp) stmt else stmt • 然后把句型中的第一个stmt展开，选择产生式stmt → while (exp) stmt，得到句型if (exp) while (exp) stmt else stmt • 再展开下个stmt，得到if (exp) while (exp) a else stmt … 50 预测分析表构造算法 • 输入：文法G • 输出：预测分析表M • 方法 – 对于文法G的每个产生式A → α • 对于FIRST(α)中的每个终结符号a，将A → α加入到M[A, a]中 • 如果ε在FIRST(α)，那么对于FOLLOW(A)中的每个符号b，将 A → α也加入到M[A, b]中 – 最后在所有的空白条目中填入error 51 例子 • 文法： • FIRST集 – E, T, F: { (, id } E': { +, ε } T': { *, ε } • FOLLOW集 – E, E': { $, ) } T, T': { +, $, ) } F: { *, +, $, ) } 52 预测分析表冲突的例子 • 文法：S → i E t S S' | a S' → e S | ε E → b – FIRST(eS) = { e }，使得S' → eS在M[S', e]中 – FOLLOW(S') = { $, e }，使得S' → ε也在M[S', e]中 • LL(1)文法必然不是二义性的，而这个文法是二义 性的 53 LL(1)文法的递归下降分析 • 递归下降语法分析程序由一组过程组成 • 每个非终结符号对应于一个过程，该过程负责扫 描该非终结符号对应的结构 • 可以使用当前的输入符号来唯一地选择产生式 54 如果当前输入符号为 a，那么选择M[A, a] 中的产生式 非递归的预测分析 (1) • 在自顶向下分析的过程中，我们总是 – 匹配掉句型中左边的所有终结符号 – 对于最左边的非终结符号，选择适当的产生式展开 – 匹配成功的终结符号不会再被考虑，因此只需要记住 句型的余下部分，以及尚未匹配的输入终结符号串 – 由于展开的动作总是发生在余下部分的左端，我们可 以用栈来存放这些符号 55 非递归的预测分析 (2) • 分析时的处理过程 – 初始化时，栈中仅包含开始符号S (和$) – 如果栈顶元素是终结符号，那么进行匹配 – 如果栈顶元素是非终结符号 • 使用预测分析表来选择适当的产生式 • 在栈顶用产生式右部替换产生式左部 • 对所有文法的预测分析都可以用同样的驱动程序 56 分析表驱动的预测分析器 • 栈中符号序列为α，w 是已读入的输入，w' 是余下的输入，那么 – S推导出wα – 试图从α推导出余下的 输入w' • 预测分析程序使用 M[X, a]来扩展X，将 产生式的右部按倒序 压入栈中 57 w w'  w 预测分析算法 • 输入：串w，预测分析表M • 输出：如果w是句子，输出w的最左推导；否则报错 (1) 初始化：输入缓冲区中为w$，栈中为S$，ip指向w的第一个符号 (2) 令X = 栈顶符号，ip指向输入符号a if (X == a) X出栈，ip向前移动 // 与终结符号匹配成功 else if (X是终结符号) error() // 失配 else if (M[X, a]是报错条目) error() // 无适当的产生式 else if (M[X, a] = X → Y1Y2…Yk) { 输出产生式X → Y1Y2…Yk 弹出栈顶符号X，并将Yk, Yk-1, …, Y1压入栈中 } (3) 不断执行第二步，直到要么报错，要么栈中为空 58 • 输入： id + id * id 59 已匹配的部分加上栈 中的符号必然是一个 最左句型 分析表驱动预测分析的例子自底向上的语法分析 • 为一个输入串构造语法分析树的过程 • 从叶子 (输入串中的终结符号，将位于分析树的底 端) 开始，向上到达根结点 – 在实际的语法分析过程中并不一定会构造出相应的分 析树，但是用分析树的概念可以方便理解 • 重要的自底向上语法分析的通用框架 – 移入-归约 (shift-reduce) • 简单LR技术 (SLR)、LR技术 (LR) 60 分析过程示例 61 归约 • 自底向上的语法分析过程可以看成是从串w归约 为文法开始符号S的过程 • 归约 (reduction) 步骤 – 一个与某产生式体相匹配的特定子串被替换为该产生 式头部的非终结符号 • 问题 – 何时归约 (归约哪些符号串) ？ – 归约到哪个非终结符号？ 62 例子 • id * id的归约过程 – id * id，F * id，T * id，T * F，T，E • 对于句型T * id，有两个子串和某产生式右部匹配 – T是E → T的右部 – id是F → id的右部 – 为什么选择将id归约为F，而不是将T归约为E？ • 原因：T归约为E之后，E * id不再是句型 • 问题：如何确定这一点？ 63 句柄 • 对输入从左到右扫描，并进行自底向上的语法分 析，实际可以反向构造出一个最右推导 • 句柄 (handle) – 最右句型中和某个产生式体相匹配的子串，对它的归 约代表了该最右句型的最右推导的最后一步 – 正式定义：如果S αAw αβw，那么紧跟α之后 的β是A → β的一个句柄 • 在一个最右句型中，句柄右边只有终结符号 • 如果文法是无二义性的，那么每个句型有且只有 一个句柄 64 例子 • 输入：id * id 65 移入-归约分析技术 • 使用一个栈来保存归约/扫描移入的文法符号 • 栈中符号 (从底向上) 和待扫描的符号组成了一个 最右句型 • 开始时刻：栈中只包含$，而输入为w$ • 结束时刻：栈中为S$，而输入为$ • 在分析过程中，不断移入符号，并在识别到句柄 时进行归约 • 句柄被识别时总是出现在栈的顶部 (后面解释) 66 主要分析动作 • 移入 (shift)：将下一个输入符号移入到栈顶 • 归约 (reduce)：将句柄归约为相应的非终结符号 – 句柄总是在栈顶 – 具体操作时弹出句柄，压入被归约到的非终结符号 • 接受 (accept)：宣布分析过程成功完成 • 报错 (error)：发现语法错误，调用错误恢复子程 序 67 例子 68 为什么句柄总是在栈顶？ • 为什么每次归约得到的新句型的句柄仍在栈顶？ • 考虑最右推导的两个连续步骤的两种情况 – 情况1)：A被替换为βBy，然后产生式体中的最右非终 结符号B被替换为γ (归约之后句柄为βBy) – 情况2)：A首先被展开，产生式体中只包含终结符号， 下一个最右非终结符号B位于y左侧 69 移入-归约分析中的冲突 • 对于有些不能使用移入-归约分析的文法，不管用 什么样的移入-归约分析器都会到达这样的格局 – 即使知道了栈中所有内容、以及下面k个输入符号，人 们仍然无法知道是否该进行归约 (移入-归约冲突)，或 者不知道按照什么产生式进行归约 (归约-归约冲突) – 设栈中符号串是αβ，接下来的k个符号是x，产生移入/ 归约冲突的原因是存在y和y'使得aβxy是最右句型且β是 句柄 (需归约)，而aβxy'也是最右句型，但是句柄还在 右边 (需移入) 70 移入-归约冲突的例子 71 归约-归约冲突的例子 • 输入为id ( id , id ) • 冲突时的格局 – 栈：… id ( id 输入：, id ) … 72 LR语法分析技术 • LR(k)的语法分析概念 – L表示最左扫描，R表示反向构造出最右推导 – k表示最多向前看k个符号 • 当k增大时，相应的语法分析器的规模急剧增大 – k = 2时，程序语言的语法分析器的规模通常非常庞大 – 当k = 0, 1时，已经可以解决很多语法分析问题，因此 具有实践意义 – 我们只考虑k <= 1的情况 73 LR语法分析器的优点 • 由表格驱动，虽然手工构造表格工作量很大，但 表格可以自动生成 • 对于几乎所有的程序设计语言，只要写出上下文 无关文法，就能够构造出识别该语言的LR语法分 析器 • 最通用的无回溯移入-归约分析技术 • 能分析的文法比LL(k)文法更多 – 真超集 74 LR(0)项 • 项 (item)：文法的一个产生式加上在其中某处的 一个点 – A → XYZ，A → XYZ，A → XYZ，A → XYZ – 注意：A → ε只对应一个项A →  • 直观含义 – 项A → αβ表示已经扫描/归约到了α，并期望在接下来 的输入中经过扫描/归约得到β，然后把αβ归约到A – 如果β为空，表示我们可以把α归约为A • 项也可以用一对整数表示：(i, j)表示第i条产生式， 点位于右部第j个位置 75 LR(0)项集规范族的构造 • 三个相关定义 – 增广文法 – 项集闭包CLOSURE – GOTO函数 • 增广文法 (augmented grammar) – G的增广文法G'是在G中增加新开始符号S'，并加入产 生式S' → S而得到的 – 显然G'和G接受相同的语言，且按照S' → S进行归约实 际上就表示已经将输入符号串归约成为开始符号 76 项集闭包CLOSURE • 项集闭包 (CLOSURE)：如果I是文法G的一个项集 ，CLOSURE(I)就是根据下列两条规则从I构造得 到的项集 – 将I中的各项加入CLOSURE(I)中 – 如果A → αBβ在CLOSURE(I)中，而B → γ是一个产生 式，且项B → γ不在CLOSURE(I)中，就将该项加入其 中，不断应用该规则直到没有新项可加入 • 意义 – A → αBβ，表示希望看到由Bβ推导出的串，那要先看 到由B推导出的串，因此加上B的各个产生式对应的项 77 CLOSURE(I)的构造算法 78 例子 • 增广文法 – E' → E E → E + T | T T → T * F | F – F → ( E ) | id • 项集{ [E' →  E] }的闭包 – [E' →  E]在闭包中 – [E →  E + T], [E →  T]在闭包中 – [T →  T * F], [T →  F]在闭包中 – [F →  ( E )], [F →  id]在闭包中 79 GOTO函数 • GOTO函数 – I是一个项集，X是一个文法符号，则GOTO(I, X)定义 为I中所有形如[A → αXβ]的项所对应的项[A → αXβ] 的集合的闭包 • 例如 – I = { [E' → E ], [E → E  + T] } – GOTO(I, +)计算如下 • I中只有一个项的点后面跟着+，对应的项为[E → E +  T] • CLOSURE({ [E → E +  T] }) = { [E → E +  T], [T →  T * F], [T →  F], [F →  ( E )], [F →  id] } 80 求LR(0)项集规范族的算法 • 从初始项集开始，不断计算各种可能的后继，直 到生成所有的项集 8182 项集规范族构造示例LR(0)自动机的构造 • 构造方法 – 基于规范LR(0)项集族可以构造LR(0)自动机 – 规范LR(0)项集族中的每个项集对应于LR(0)自动机的一 个状态 – 状态转换：如果GOTO(I, X) = J，则从I到J有一个标号 为X的转换 – 开始状态为CLOSURE({ S' → S })对应的项集 83 LR(0)自动机的作用 (1) • 假设文法符号串γ使LR(0)自动机从开始状态运行 到状态 (项集) j • 如果j中存在项A → α，那么 – 在γ之后添加一些终结符号可以得到一个最右句型 – α是γ的后缀，且是该句型的句柄 (对应于产生式A → α) – 表示可能找到了当前最右句型的句柄，可以归约 • 如果j中存在项B → αXβ，那么 – 在γ之后添加Xβ和一些终结符号可以得到一个最右句型 – 该句型中αXβ是句柄，但还没找到，还需移入 84 LR(0)自动机的作用 (2) • LR(0)自动机的使用 – 移入-归约时，LR(0)自动机被用于识别句型 – 已得到的文法符号序列对应于LR(0)自动机的一条路径 • 无需每次用该文法符号序列来运行LR(0)自动机 – 文法符号可省略，由LR(0)状态可确定相应的文法符号 – 在移入后，根据原来的栈顶状态可以知道新的状态 – 在归约时，根据归约产生式的右部长度弹出相应状态， 也可以根据此时的栈顶状态知道新的状态 85 LR(0)自动机的作用的演示 • 分析id * id – 栈中只保留状态，文法符号可以从相应的状态中获取 86非必需 LR语法分析器的结构 • 所有的分析器都使用相同的驱动程序 • 分析表随文法以及LR分析技术的不同而不同 • 栈中存放的是状态序列，可求出相应的符号序列 • 分析程序根据栈顶状态和当前输入，通过分析表 确定下一步动作 87 LR语法分析表的结构 • 两个部分：动作ACTION、转换GOTO • ACTION表项有两个参数：状态i，终结符号a – 移入j：j是新状态，把j压入栈 (同时移入a) – 归约A → β：把栈顶的β归约为A (并根据GOTO表项压 入新状态) – 接受：接受输入，完成分析 – 报错：在输入中发现语法错误 • GOTO表项 – 如果GOTO[Ii, A] = Ij，那么GOTO[i, A] = j 88 GOTO函数 GOTO表项 LR语法分析器的格局 • LR语法分析器的格局 (configuration) 包含了栈中 内容和余下输入(s0s1…sm, aiai+1…an$) – 第一个分量是栈中的内容 (右侧是栈顶) – 第二个分量是余下的输入 • LR语法分析器的每一个状态都对应一个文法符号 (s0除外) – 如果进入状态s的边的标号为符号X，那么s就对应于X – 令Xi为si对应的符号，那么X1X2…Xmaiai+1…an对应于一 个最右句型 89 LR语法分析器的行为 • 对于格局(s0s1…sm, aiai+1…an$)，LR语法分析器查 询条目ACTION[sm, ai]确定相应的动作 – 移入s：执行移入动作，将状态s (对应输入ai) 移入栈中， 得到新格局 (s0s1…sms，ai+1…an$) – 归约A → β：将栈顶的β归约为A，压入状态s，得到新 格局 (s0s1…sm-rs，aiai+1…an$)，其中r是β的长度，状态s = GOTO[sm-r, A] – 接受：语法分析过程完成 – 报错：发现语法错误，调用错误恢复例程 90 LR语法分析算法 • 输入：文法G的LR语法分析表，输入串w • 输出：如果w在L(G)中，则输出自底向上语法分析 过程中的归约步骤，否则输出错误指示 • 算法如下： 91 LR分析表的例子 • 文法： 92 LR分析过程的例子 • 输入：id * id + id 93 SLR语法分析表的构造 • 以LR(0)自动机为基础的SLR语法分析表构造算法 – 构造增广文法G'的LR(0)项集规范族{ I0, I1, …, In } – 状态i对应项集Ii，相关的ACTION/GOTO表条目如下 • [A → αaβ]在Ii中，且GOTO(Ii, a) = Ij，则ACTION[i, a] = \"移 入j\" • [A → α]在Ii中，那么对FOLLOW(A)中所有a，ACTION[i, a] = \"按A → α归约\" • 如果[S' → S]在Ii中，那么将ACTION[i, $]设为\"接受\" • 如果GOTO(Ii, A) = Ij，那么在GOTO表中，GOTO[i, A] = j – 空白的条目设为\"error\" • 如果SLR分析表没有冲突，该文法就是SLR的 思想：把归约成为A，后面需是FOLLOW(A)中的终结符号，否则只能移入 94 SLR分析表构造的例子 • 项集I0 E' → E E → E+T E → T T → T*F T → F F → (E) F → id – ACTION[0, (] = s4 ACTION[0, id] = s5 – GOTO[0, E] = 1 GOTO[0, T] = 2 GOTO[0, F] = 3 • 项集I1：E' → E E → E+T – ACTION[1, +] = s6 ACTION[1, $] = 接受 • 项集I2：E → T T → T*F – ACTION[2, *] = s7 ACTION[2, +/)/$] = 归约E → T 95 非SLR(1)文法的例子 • 文法 – S → L = R | R – L → *R | id – R → L • 对于项集I2 – 第一个项使 ACTION[2, =] = s6 – 第二个项使 ACTION[2, =] = 归 约R → L 96 可行前缀 (1) • LR(0)自动机刻画了可能出现在移入-归约语法分 析栈中的文法符号串 • 可行前缀 (viable prefix) – 可以出现在语法分析器栈中的最右句型的前缀，且没 有越过该句型的句柄的右端 • 有效项 – 如果存在一个推导过程S到αAw => αβ1β2w，那么我们 说项A → β1β2是可行前缀αβ1的有效项 97 可行前缀 (2) • 如果我们知道项A → β1β2对αβ1有效 – 当β2不等于空，表示句柄尚未出现在栈中，应该移入 – 如果β2等于空，表示句柄已出现在栈中，应该归约 • 如果在某个时刻存在两个有效项要求对同一个可 行前缀执行不同的动作，就应该设法解决冲突 – 冲突实际上表示该可行前缀可能是两个最右句型的前 缀，第一个包含了句柄，而另一个尚未包含句柄 – 也可能都认为包含句柄，但是规则不一样 98 可行前缀 (3) • SLR解决冲突的思想 – 假如要按照A → β进行归约，只有当下一个输入符号在 FOLLOW(A)中时才可以归约 – 不是所有的冲突都能通过查看下一个输入符号来解决 99 可行前缀的例子 • 可行前缀E + T * • 对应LR(0)项I7 – T → T*F – F → (E) – F → id • 对应的最右推导 – E' => E => E + T => E + T * F – E' => E => E + T => E + T * F => E + T * ( E ) – E' => E => E + T => E + T * F => E + T * id 100 SLR语法分析器的弱点 (1) • SLR技术解决冲突的方法 – 项集中包含[A → α]时，按照A → α进行归约的条件是 下一个输入符号a可以在某个句型中跟在A之后 • 如果此时对于a还有其它的移入/归约操作，则出现冲突 – 假设此时栈中的符号串为βα • 如果βAa不是任何最右句型的前缀，那么即使a在某个句型中 跟在A之后，仍不应该按A → α归约 • 进行归约的条件更加严格可以降低冲突的可能性 101 SLR语法分析器的弱点 (2) • [A → α]出现在项集中的条件 – 首先[A → α]出现在某个项集中，然后逐步读入/归约 到α中的符号，点不断后移，到达末端 – 而[A → α]出现的条件是B → βAγ出现在项中 – 期望首先按照A → α归约，然后将B → βAγ中的点移 到A之后 – 显然，在按照A → α归约时要求下一个输入符号是γ的 第一个符号，但是从LR(0)项集中不能确定这个信息 102 更强大的LR语法分析器 • 规范LR方法 (LR方法) – 添加项[A → α]时，把期望的向前看符号也加入项中 (成为LR(1)项集) – 这个做法可以充分利用向前看符号，但是状态很多 • 向前看LR (LALR方法) – 基于LR(0)项集族，但每个LR(0)项都带有向前看符号 – 分析能力强于SLR方法，且分析表和SLR分析表一样大 – LALR已经可以处理大部分的程序设计语言 103 LR(1)项 • LR(1)项中包含更多信息来消除一些归约动作 • 实际的做法相当于“分裂”一些LR(0)状态，精确 指明何时应该归约 • LR(1)项的形式[A → αβ, a] – a称为向前看符号，可以是终结符号或者$ – a表示如果将来要按照A → αβ进行归约，归约时的下一 个输入符号必须是a – 当β非空时，移入动作不考虑a，a传递到下一状态 104 LR(1)项和可行前缀 • [A → αβ, a]对一个可行前缀γ有效的条件 – 存在一个推导S δAw δαβw – 其中γ = δα，且a是w的第一个符号，或w为空且a = $ • 如果[A → αBβ, a]对于可行前缀γ有效，那么 – [B → θ, b]对于γ有效的条件是什么？ – S δAw δαBβw δαBxw δαθxw – b应该是xw的第一个符号，或xw为空且b = $ – 如果x为空，则b = a • 如果[A → αXβ, a]对可行前缀γ有效，那么 – [A → αXβ, a]对γX有效 105 构造LR(1)项集 • LR(1)项集族的构造和LR(0)项集族类似，但是 CLOSURE和GOTO有所不同 – 在CLOSURE中，当由项[A → αBβ, a]生成新项[B → θ, b]时，b必须在FIRST(βa)中 – 对LR(1)项集中的任意项[A → αBβ, a]，总有：a在 FOLLOW(A)中 • 初始项满足这个条件 • 每次求CLOSURE项集时，新产生的项也满足这个条件 107 LR(1)项集的CLOSURE算法 • 注意在添加[B → γ, b]时，b的取值范围 108 LR(1)项集的GOTO算法 • 和LR(0)项集的GOTO算法基本相同 109 LR(1)项集族的构造算法 • 和LR(0)项集族的构造算法相同 110 课本有误， 此处修正 例子 (1) • 增广文法 – S' → S S → C C C → c C | d • 构造I0项集和GOTO函数 – I0 = CLOSURE{ [S' → S, $] } = • { [S' → S, $], [S → CC, $], [C → cC, c/d], [C → d, c/d] } – GOTO(I0, S) = { [S' → S, $] } – GOTO(I0, C) = CLOSURE{ [S → CC, $] } = • { [S → CC, $], [C → cC, $], [C → d, $] } – GOTO(I0, c) = CLOSURE{ [C → cC, c/d] } = • { [C → cC, c/d], [C → cC, c/d], [C → d, c/d] } – GOTO(I0, d) = { [C → d, c/d] } 111 例子 (2) 112 不计向前看符号 – I3, I6相同 – I4, I7相同 – I8, I9相同 共10个状态 LR(1)语法分析表的构造 • 步骤 – 构造得到LR(1)项集族C' = { I0, I1, …, In } – 状态i对应于项集Ii，其分析动作如下 • [A → αaβ, b]在项集中，且GOTO(Ii, a) = Ij，那么ACTION[i, a] = \"移入j\" • [A → α, a]在项集中，那么ACTION[i, a] = \"按照A → α归约\" • [S' → S, $]在项集中，那么ACTION[i, $] = \"接受\" – GOTO表项：GOTO[i, A] = j，如果GOTO(Ii, A) = Ij – 没有填写的条目为error – 如果条目有冲突，则不是LR(1)的 – 初始状态对应于[S' → S, $]所在的项集 113 例子 • (3, 6), (4, 7), (8, 9)可 看作是由原来的一个 LR(0)状态拆分而来 114 文法： S' → S S → C C C → c C | d 构造LALR语法分析表 • SLR(1)语法分析表的分析能力较弱 • LR(1)语法分析表的状态数量很大 • LALR(1)是实践中常用的方法 – 状态数量和SLR(1)的状态数量相同 – 能够方便地处理大部分常见程序设计语言的构造 115 LR(1)语法分析表的合并 • 4和7在向前看符号上不同 – [C → d, c/d] vs. [C → d, $] – 状态4：下个符号为c/d则 归约，为$则报错 – 状态7：分析动作正好相反 • 如果将4和7中的项合并得 47，则所有情况下都归约 – 对这个文法，合并不会引 起冲突，但有些文法会 116 文法： S' → S S → C C C → c C | d LALR分析技术的基本思想 • 寻找具有相同核心的LR(1)项集，并把它们合并成 为一个项集 – 项集的核心 (core) 就是项的第一分量的集合 • I4和I7的核心都是{ C → d } • I3和I6的核心{ C → cC, C → cC, C → d } • 一个LR(1)项集的核心是一个LR(0)项集 • GOTO(I, X)的核心只由I的核心决定，因此被合并 项集的GOTO目标也可以合并 – 这表示合并之后，我们仍可以建立GOTO关系 117 合并引起的冲突 • 原来无冲突的LR(1)分析表在合并之后得到 LALR(1)分析表，新表中可能存在冲突 • 合并不会导致移入/归约冲突 – 假设合并之后在a上存在移入/归约冲突，即存在项[B → βaγ, ?]和[A → α, a] – 因为被合并的项集具有相同的核心，因此被合并的所 有项集中都包括[B → βaγ, ?]，而[A → α, a]也必然在 某个项集中，那么这个项集必然已经存在冲突！ • 合并会引起归约/归约冲突，即不能确定按照哪个 产生式进行归约 118 合并引起归约/归约冲突的例子 • 文法： – S' → S S → a A d | b B d | a B e | b A e – A → c B → c • 语言：{ acd, bcd, ace, bce } • 可行前缀ac的有效项集：{ [A → c, d], [B → c, e] } • 可行前缀bc的有效项集：{ [B → c, d], [A → c, e] } • 合并之后的项集为：{ [A → c, d/e], [B → c, d/e] } – 包含了归约/归约冲突：应该把c归约成为A还是B？ 119 LALR分析表构造算法 • 步骤 – 构造得到LR(1)项集族C = { I0, I1, …, In } – 对于LR(1)中的每个核心，找出所有具有该核心的项集， 并把这些项集替换为它们的并集 – 令C' = { J0, J1, …, Jm }为得到的LR(1)项集族 • 按照LR分析表的构造方法得到ACTION表 (如果存在冲突，则 这个文法不是LALR的) – GOTO表的构造：设J是一个或者多个LR(1)项集 (包括 I1)的并集，令K是所有和GOTO(I1, X)具有相同核心的 项集的并集，那么GOTO(J, X) = K • 得到的分析表称为LALR语法分析表 120 例子 • LR(1)项集族中有三对可以合并 – I36: [C → cC, c/d/$], [C → cC, c/d/$], [C → d, c/d/$] – I47: [C → d, c/d/$] – I89: [C → cC, c/d/$] • GOTO(I36, C) = I89 (原GOTO(I3, C) = I8) 121 文法： S' → S S → C C C → c C | d LALR分析器和LR分析器 • 处理语法正确的输入时，LALR语法分析器和LR 语法分析器的动作序列完全相同 – 栈中的状态名字不同，但是状态序列之间有对应关系 – 如果LR分析器压入状态I，那么LALR分析器压入I对应 的合并项集 • 当LR分析器压入状态I3时，LALR分析器压入状态I36 • 当处理错误的输入时，LALR可能多执行一些归约 动作，但不会多移入一个符号 122 LALR技术本质 • 对LR(1)项集规范族中的同核心项集进行合并 – 使得分析表保持了LR(1)项中的向前看符号信息 – 又使状态数减少到与SLR分析表的一样多 123 二义性文法的使用 • 二义性文法都不是LR的 • 某些二义性文法是有用的 – 可以简洁地描述某些结构 – 隔离某些语法结构，对其进行特殊处理 • 对于某些二义性文法 – 可以通过消除二义性规则来保证每个句子只有一棵语 法分析树 – 可以在LR分析器中实现这个规则 124 优先级/结合性消除冲突 • 二义性文法 – E → E + E | E * E | ( E ) | id • 等价于 – E → E + T | T T → T * F | F F → (E) | id • 二义性文法的优点 – 容易修改算符的优先级和结合性 – 简洁：如果有多个优先级，那么无二义性文法将引入 太多的非终结符号 – 高效：不需要处理像E → T这样的归约 125 二义性表达式文法的LR(0)项集 • 文法 – E → E + E | E * E | ( E ) | id • 冲突 – I7、I8中有冲突， 且不可能通过向 前看符号解决！ 126 冲突的原因以及解决 • 当栈顶状态为7时，表明 – 栈中状态序列对应的文法符号序列为：… E + E – 如果下一个符号为+或*，移入还是归约？ • 如果*的优先级大于+，且+是左结合的 – 下一个符号为*时，我们应该移入* – 下一个符号为+时，我们应该将E + E归约为E • 栈顶状态为8时，有类似情况 127 解决冲突之后的SLR(1)分析表 • 对于状态7 – +时归约 – *时移入 • 对于状态8 – 总执行归约 • 这个表和等价的无 二义性文法的分析 表类似 128 悬空else的二义性 • 文法 S' → S S → i S e S | i S | a • 项集I4包含冲突 – 栈中符号为：i S • 冲突 – 下一个符号为e，因栈中i未匹配，该移入e – 如果下一个符号属于FOLLOW(S)，该归约 – 解决：移入 129 语法错误的处理 • 错误难以避免，编译器需要有处理错误的能力 • 程序中可能存在不同层次的错误 – 词法错误、语法错误、语义错误、逻辑错误 • 语法分析器中错误处理程序的设计目标 – 清晰准确地报告出现的错误，并指出错误的位置 – 能从当前错误中恢复，以继续检测后面的错误 – 尽可能地减少开销 130 预测分析中的错误恢复 • 错误恢复 – 当预测分析器报错时，表示输入的串不是句子 – 使用者希望预测分析器能够进行恢复处理后继续语法 分析过程，以便在一次分析中找到更多的语法错误 – 可能恢复得并不成功，之后找到的语法错误是假的 – 进行错误恢复时可用的信息：栈里面的符号、待分析 的符号 • 两类错误恢复方法 – 恐慌模式、短语层次的恢复 131 恐慌模式 • 基本思想 – 语法分析器忽略输入中的一些符号，直到出现由设计 者选定的某个同步词法单元 – 解释 • 语法分析过程总是试图在输入前缀中找到和某个非终结符号对 应的串，出现错误表明已经不可能找到对应这个非终结符号 (程序结构) 的串了 • 如果编程错误仅局限于这个程序结构，我们可考虑跳过该程序 结构，假装已经找到了它，然后继续进行语法分析处理 – 同步词法单元 (synchronizing token) 就是这个程序结 构结束的标志 132 同步词法单元的确定 • 文法符号A的同步集合的启发式规则 – 将FOLLOW(A)中所有符号放入A的同步集合中 – 将高层次非终结符号对应串的开始符号加入到较低层 次非终结符号的同步集合 • 比如：语句的开始符号，if/while等可作为表达式的同步集合 – 将FIRST(A)中的符号加入到A的同步集合 • 碰到这些符号时，可能意味着前面的符号是多余的符号 – 如果A可以推导出空串，把该产生式当作默认值 – 在栈顶的终结符号出现匹配错误时，可直接弹出该符 号，并且发出消息称已经插入了这个终结符号 • 根据特定应用来决定哪些符号需要确定同步集合 133 非 终 结 符 终 结 符 恐慌模式的例子 (1) • 对E, T, F的表达式进行语法分析时，可直接使用 其FOLLOW值作为同步集合 – synch表示一直忽略到同步集合，然后弹出非终结符号 – 空条目表示忽略输入符号 (多) – 终结符号不匹配时，弹出栈中终结符号 (漏) 134 恐慌模式的例子 (2) • 错误输入 – + id * + id 135 + + FOLLOW(F) = { *, +, $, ) } 短语层次的恢复 • 在预测语法分析表的空白条目中插入错误处理例 程的函数指针 – 例程可以改变、插入或删除输入中的符号，并发出适 当的错误消息 136 LR语法分析中的错误恢复 (1) • 查询ACTION表时可能发现报错条目 – 假设栈中的符号串为α，当前输入符号为a，报错表示 不可能存在终结符号串x使得αax是一个最右句型 • 恐慌模式的错误恢复策略 – 从栈顶向下扫描，找到状态s，s有一个对应于某个非终 结符号A的GOTO目标 (s之上的状态被丢弃) – 在输入中丢弃一些符号，直到一个可以跟在A之后的符 号b (不丢弃b)，并将GOTO(s, A)压栈，继续进行分析 – 基本思想：假定当前试图归约到A但碰到了语法错误， 因此设法扫描完包含语法错误的A的子串，假装找到了 A的一个实例 137 LR语法分析中的错误恢复 (2) • 短语层次的恢复 – 检查LR分析表中的每个报错条目，根据语言的特性来 确定程序员最可能犯了什么错误，然后构造适当的恢 复程序 138 语法分析器生成工具Yacc • Yacc/Bison的使用方法如下 139 C语言写 的LALR语 法分析器 Yacc源程序的结构 • 声明 – 放置C声明和对词法单元的声明 • 翻译规则 – 指明产生式及相关的语义动作 • 辅助性C语言例程 – 被直接拷贝到生成的C语言源程序中 – 可在语义动作中调用 – 包括yylex()，这个函数返回词法单元，可以由Lex生成 140 声明 %% 翻译规则 %% 辅助性C语言例程 翻译规则的格式 • 说明 – 第一个产生式的头被看作开始符号 – 语义动作是C语句序列 – $$表示和产生式头相关的属性值，$i表示产生式体中第 i个文法符号的属性值 – 在按照某个产生式归约时，执行相应的语义动作，可 以根据$i来计算$$的值 <产生式头> : <产生式体1> { <语义动作1> } | <产生式体2> { <语义动作2> } …… | <产生式体n> { <语义动作n> } ; 141 Yacc源程序的例子 142 Yacc中的冲突处理 • 缺省处理方法 – 归约/移入冲突：总是移入 (悬空else的解决) – 归约/归约冲突：选择列在前面的产生式 – 选项-v可在文件y.output中看到冲突的描述和解决方法 • 通过确定终结符号的优先级/结合性来解决冲突 – 结合性：%left, %right, %nonassoc – 移入a/按A → α归约：比较a和A → α的优先级再选择 • 终结符号的优先级按在声明部分的出现顺序而定 • 产生式的优先级设为它最右的终结符号的优先级，也可以加标 记%prec<终结符号>，指明产生式的优先级等同于该终结符号 143 Yacc的错误恢复 • 使用错误产生式来完成语法错误恢复 – 错误产生式A → error α – 例如：stmt → error ; • 定义哪些非终结符号有错误恢复动作 – 比如：表达式、语句、块、函数定义等非终结符号 • 当语法分析器遇到错误时 – 不断弹出栈中状态，直到栈顶状态包含项A →  error α – 分析器将error移入栈中 – 如果α为空，分析器直接执行归约，并调用相关的语义 动作；否则跳过一些符号，找到可以归约为α的串为止 144","libVersion":"0.3.2","langs":""}