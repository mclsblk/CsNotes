{"path":"docs/学校课程/归档课程/编译原理/课件/Chapter_5.pdf","text":"许畅 南京大学计算机系 2024年春季 第五章 语法制导的翻译 版权所有 南京大学计算机科学与技术系 许畅 2024春季版 介绍 • 使用上下文无关文法引导语言的翻译 – CFG的非终结符号代表了语言的某个构造 – 程序设计语言的构造由更小的构造组合而成 – 一个构造的语义可以由小构造的含义综合而来 • 比如：表达式x + y的类型由x、y的类型和运算符+决定 – 也可以从附近的构造继承而来 • 比如：声明int x中x的类型由它左边的类型表达式决定 2 语法制导定义和语法制导翻译 • 语法制导定义 – 将文法符号和某些属性相关联，并通过语义规则来描 述如何计算属性的值 • E → E1 + T E.code = E1.code || T.code || '+' – 属性code代表表达式的逆波兰表示，规则说明加法表达 式的逆波兰表示由两个分量的逆波兰表示并置，然后 加上'+'得到 (中缀表达式 => 后缀表达式) • 语法制导翻译 – 在产生式体中加入语义动作，并在适当时候执行动作 • E → E1 + T { print '+'; } 3 语法制导的定义 (SDD) • Syntax-Directed Definition (SDD) 是上下文无 关文法和属性/规则的结合 – 属性和文法符号相关联，按照需要来确定各个文法符 号需要哪些属性 – 规则和产生式相关联 • 对于文法符号X和属性a，我们用X.a表示分析树中 某个标号为X的结点的值 – 一个分析树结点和它的分支对应一个产生式规则，而 对应的语义规则确定了这些结点上属性的取值和计算 4 分析树和属性值 (1) • 假设需要知道一个表达式的类型，以及对应代码 将它的值存放的内存地址 – 我们需要两个属性：type, place • 产生式规则：E → E1 + T – 假设只有int/float类型 – E.type = if (E1.type == T.type) T.type else float; – E.place = newTempPlace(); // 返回一个新的内存位置 • 产生式规则：F → id – F.type = lookupIDTable(id.lexValue)->type; – F.place = lookupIDTable(id.lexValue)->address; 5 分析树和属性值 (2) • 输入a + b * c的语法分析树以及属性值 6 (1) 假设a, b, c是已声 明的全局变量，a 的类型为float， b和c的类型为int (2) 中间未标明的T 和F的type和place 是int和&b E E T+ T F id T F* F id id id.lexValue = a F.type = float F.place = &a T.type = float T.place = &a E.type = float E.place = &a T.type = int T.place = &tmp1 F.type = int F.place = &c id.lexValue = c id.lexValue = b E.type = float E.place = &tmp2 综合属性和继承属性 • 综合属性 (synthesized attribute) – 结点N的属性值由N的产生式所关联的语义规则来定义 – 通过N的子结点或N本身的属性值来定义 • 继承属性 (inherited attribute) – 结点N的属性值由N的父结点所关联的语义规则来定义 – 依赖于N的父结点、N本身和N的兄弟结点上的属性值 • 几条约束 – 不允许N的继承属性通过N的子结点上的属性来定义， 但允许N的综合属性依赖于N本身的继承属性 – 终结符号有综合属性 (来自词法分析)，但无继承属性 7 SDD的例子 • 计算表达式行L的值 (属性val) • 计算L的val值需要E的val值，E的val值又依赖于E1 和T的val值，… • 终结符号digit有综合属性lexval 8 S属性的SDD • 只包含综合属性的SDD称为S属性的SDD – 每个语义规则都根据产生式体中的属性值来计算头部 非终结符号的属性值 • S属性的SDD可以和LR语法分析器一起实现 – 栈中的状态/文法符号可以附加相应的属性值 – 归约时，按照语义规则计算归约得到的符号的属性值 • 语义规则不应该有复杂的副作用 – 要求副作用不影响其它属性的求值 – 没有副作用的SDD称为属性文法 (attribute grammar) 9 语法分析树上的SDD求值 (1) • 实践中很少先构造语法分析树再进行SDD求值， 但在分析树上求值有助于翻译方案的可视化，便 于理解 • 注释语法分析树 (annotated parse tree) – 包含了各个结点的各属性值的语法分析树 • 步骤 – 对于任意的输入串，首先构造出相应的分析树 – 给各个结点 (根据其文法符号) 加上相应的属性 – 按照语义规则计算这些属性的值 10 语法分析树上的SDD求值 (2) • 按照分析树中的分支对应的文法产生式，应用相 应的语义规则计算属性值 • 计算顺序 – 如果某个结点N的属性a为f(N1.b1, N2.b2, …, Nk.bk)，那 么我们需要先算出N1.b1, N2.b2, …, Nk.bk的值 • 如果可以给各个属性值排出计算顺序，那么这个 注释分析树就可以计算得到 – S属性的SDD一定可以按照自底向上的方式求值 • 下面的SDD不能计算 (循环定义) – A → B A.s = B.i B.i = A.s + 1 11 注释分析树的例子 12 3 * 5 + 4 n 适用于自顶向下分析的SDD (1) • 前面的文法存在左递归，我们无法用自顶向下的 分析方法进行处理 • 但消除左递归之后，我们无法直接使用属性val进 行处理 (语法树结构与抽象语法不匹配) – 比如规则：T → F T' T' → * F T' |  – T对应的项中，第一个因子对应F，而运算符却在T'中 – 需要用继承属性来完成这样的计算 13 比较T → T * F | F 适用于自顶向下分析的SDD (2) T'的属性inh实际上继承了相应的*号的左运算分量 14 比较T → T * F | F 3 * 5的注释分析树 • 观察inh属性的传递 15 消除直接左递归时语义规则的处理 • 假设 – A → A1 Y A.a = g(A1.a, Y.y) – A → X A.a = f(X.x) • 那么 – A → X R R.i = f(X.x); A.a = R.s – R → Y R1 R1.i = g(R.i, Y.y); R.s = R1.s – R → ε R.s = R.i 16 R即是我们以前消除左递归时引入的A' SDD的求值顺序 • 在对SDD的求值过程中 – 如果结点N的属性a依赖于结点M1的属性a1，M2的属性 a2，…那么我们必须先计算出Mi的属性ai，才能计算N 的属性a • 使用依赖图 (dependency graph) 来表示计算顺序 – 这些值的计算顺序形成一个偏序关系，如果依赖图中 出现了环，表示属性值无法计算 17 依赖图 • 描述了某棵特定的分析树上各个属性之间的信息 流 (计算顺序) – 从实例a1到实例a2的有向边表示计算a2时需要a1的值 • 对于分析树结点N，与N关联的每个属性a都对应 依赖图的一个结点N.a 18 依赖图的例子 • 3 * 2的注释分析树 • T → F T' – T'.inh = F.val – T.val = T'.syn – 边e1, e2 19 属性值的计算顺序 • 各个属性值需要按照依赖图的拓扑排序 (topological sort) 的顺序进行计算 – 如果依赖图中存在环，则属性计算无法进行 (无法排序) • 给定一个SDD，很难判定是否存在一棵分析树， 其对应的依赖图包含环 • 但是特定类型的SDD一定不包含环，且有固定的 计算顺序 – 如：S属性的SDD，L属性的SDD 20 S属性的SDD • 每个属性都是综合属性，都是根据子构造的属性 计算出父构造的属性 • 在依赖图中，总是通过子结点的属性值来计算父 结点的属性值，可以与自底向上或自顶向下的语 法分析过程一起计算 – 自底向上 • 在构造分析树结点的同时计算相关的属性 (此时其子结点的属 性必然已经计算完毕) – 自顶向下 • 在递归子程序法中，在过程A()的最后计算A的属性 (此时A调 用的其它过程 (对应于其子结构) 已经调用完毕) 21 在分析树上计算SDD • 按照后序遍历的顺序计算属性值即可 postorder(N) { for (从左边开始，对N的每个子结点C) postorder(C); // 递归调用返回时，各子结点的属性已计算完毕 对N的各个属性求值; } • 在LR分析过程中，实际上不需要构造分析树结点 22 L属性的SDD • 每个属性 – 是综合属性，或 – 是继承属性，且A → X1X2…Xn中计算Xi.a的规则只用 • A的继承属性，或 • Xi左边的文法符号Xj的继承属性或综合属性，或 • Xi自身的继承或综合属性 (这些属性间的依赖关系不形成环) • 特点 – 依赖图中的边 • 综合属性从下到上 • 继承属性从上到下，或从左到右 – 计算一个属性值时，它所依赖的属性值都已计算完毕 23 L属性SDD和自顶向下语法分析 (1) • 在递归子程序法中实现L属性 – 对于每个非终结符号A，其所对应过程的参数为继承属 性，返回值为综合属性 • 在处理规则A → X1X2…Xn时 – 在调用Xi()之前计算Xi的继承属性值，然后以它们为参 数调用Xi() – 在该产生式对应代码的最后计算A的综合属性 – 如果所有文法符号的属性计算按上面的方式进行，计 算顺序必然与依赖关系一致 24 L属性SDD和自顶向下语法分析 (2) • L属性SDD其属性总可以按如下方式计算 L_dfvisit(n) { for m = 从左到右n的每个子节点 do { 计算m的继承属性; L_dfvisit(m); } 计算n的综合属性; } 25 L属性SDD的例子及反例 • 非L属性的例子 – A → BC A.s = B.b; B.i = f(C.c, A.s) • L属性的例子 26 具有受控副作用的语义规则 • 属性文法没有副作用，但增加了描述的复杂度 – 比如语法分析时，如果没有副作用，标识符表就必须 作为属性传递 – 可以把标识符表作为全局变量，然后通过函数来添加 新的标识符 • 受控的副作用 – 不会对属性求值产生约束，即可以按照任何拓扑顺序 求值，不会影响最终结果 – 或者对求值过程添加简单的约束 27 受控副作用的例子 • L → E n { print(E.val); } – 通过副作用打印出E的值 – 总在最后执行，不影响其它属性的求值 • 变量声明SDD中的副作用 – addType将标识符的类型信息加入标识符表中 – 只要标识符不被重复声明，其类型信息总是正确的 28 SDD的应用例子 • 抽象语法树的构造 • 基本类型和数组类型的L属性定义 29 构造抽象语法树的SDD • 抽象语法树 – 每个结点代表一个语法结构，对应于运算符 – 结点的每个子结点代表其子结构，对应于运算分量 – 表示这些子结构按照特定的方式组成了较大的结构 – 可以忽略掉一些标点符号等非本质的东西 • 抽象语法树的表示方法 – 每个结点用一个对象表示 – 对象有多个域 • 叶子结点中只存放词法值 • 内部结点中存放了op值和参数 (通常指向其它结点) 30 构造简单表达式的抽象语法树的SDD • 属性E.node指向E对应的抽象语法树的根结点 31 表达式抽象语法树的构造过程 • 输入 – a – 4 + c • 步骤 p1 = new Leaf(id, entry_a); p2 = new Leaf(num, 4); p3 = new Node('–', p1, p2); p4 = new Leaf(id, entry_c); p5 = new Node('+', p3, p4); 32 自顶向下方式处理的L属性定义 (1) • 消除左递归时，按照规则得到如下SDD 33 自顶向下方式处理的L属性定义 (2) • 对这个SDD，各属性值的计算过程与原来S属性定 义中的计算过程一致 • 继承属性可以把值从一个结构传递到另一个并列 的结构，也可把值从父结构传递到子结构 34 a 4 c a – 4 + c 类型结构 • 简化的类型表达式的语法 – T → B C – B → int | float – C → [num] C | ε • 生成类型表达式的SDD 35 类型的含义 • 类型包括两个部分：T → B C – 基本类型 B – 分量 C • 分量形如[2][3] – 表示23的二维数组 – 如：int [2][3] • 数组构造算符array (语言设计引起的结构不匹配) – array(2, array(3, int))表示抽象的23的二维数组 36 类型表达式的生成过程 • 输入：int [2][3] 37 语法制导的翻译方案 • 语法制导的翻译方案 (SDT) 是在产生式体中嵌入 语义动作 (程序片断) 的上下文无关文法 • SDT的基本实现方法 – 建立语法分析树 – 将语义动作看作是虚拟结点 – 从左到右、深度优先地遍历分析树 (前序遍历)，在访 问虚拟结点时执行相应的语义动作 • 用SDT实现两类重要的SDD (无需建分析树) – 基本文法是LR的，且SDD是S属性的 – 基本文法是LL的，且SDD是L属性的 38 例子 • 语句3 * 4 * 5的分析树 • 动作执行顺序 – A71, A5, A72, A41, A73, A42, A3 – 动作的不同实例所访问的属性 值属于不同的结点 39 T3 F3* digit: 4 digit: 5 T2 T1 F2 digit: 3 F1 * E A71 A72 A5 A41 A42 A3 A73 可在语法分析过程中实现的SDT • 实现SDT时，实际上并不会真的构造语法分析树， 而是在分析过程中执行语义动作 • 即使基础文法可以应用某种分析技术，仍可能因 为动作的缘故导致此技术不可应用 • 判断是否可在分析过程中实现 – 将每个语义动作替换为一个独有的非终结符号Mi，其 产生式为Mi → ε – 如果新的文法可以由某种方法进行分析，那么这个 SDT就可以在这个分析过程中实现 40 SDT可否用特定分析技术实现的例子 • 新文法 – L → E n M1 M1 → ε – E → E + T M2 M2 → ε – E → T M3 M3 → ε – …… 41 后缀翻译方案 • 文法可以自底向上分析 (即LR的) 且其SDD是S属 性的，必然可以构造出后缀SDT • 后缀SDT：所有动作都在产生式最右端的SDT • 构造方法 – 将每个语义规则看作是一个赋值语义动作 – 将所有的语义动作放在规则的最右端 42 后缀翻译方案的例子 • 实现桌上计算器的后缀SDT • 注意动作中对属性值的引用 – 允许语句引用全局变量、局部变量和文法符号的属性 – 文法符号的属性只能被赋值一次 43 后缀SDT的语法分析栈实现 • 可以在LR语法分析的过程中实现 – 归约时执行相应的语义动作 – 定义用于记录各文法符号属性的union结构 (可放指针) – 栈中的每个文法符号 (或状态) 都附带一个这样的union 类型的值 – 在按照产生式A → XYZ归约时，Z的属性可以在栈顶 找到，Y的属性可以在下一个位置找到，X的属性可以 在再下一个位置找到 44 分析栈实现的例子 • 假设语法分析栈存放在一个被称为stack的记录数 组中，下标top指向栈顶 – stack[top]指向这个栈的栈顶 – stack[top – 1]指向栈顶下一个位置 • 如果不同的文法符号有不同的属性集合，我们可 以使用union来保存这些属性值 – 归约时能够知道栈顶向下的各个符号分别是什么，因 此我们也能够确定各个union中存放了什么值 45 后缀SDT的栈实现 46 注意：stack[top – i]和文法符号的对应 产生式内部带有语义动作的SDT • 动作左边的所有符号 (以及动作) 处理完成后，就 立刻执行这个动作：B → X { a } Y – 自底向上分析时，在X出现在栈顶时执行动作a – 自顶向下分析时，在试图展开Y或者在输入中检测到Y 的时刻执行a • 对一般的SDT，都可以先建立分析树 (语义动作作 为虚拟结点)，然后进行前序遍历并执行动作 • 不是所有的SDT都可以在分析过程中实现 – 后缀SDT以及L属性对应的SDT可以在分析时完成 47 消除左递归时SDT的转换 (1) • 如果动作不涉及属性值，可以把动作当作终结符 号进行处理，然后消除左递归 • 原始的产生式 – E → E1 + T { print('+'); } – E → T • 转换后得到 – E → T R – R → + T { print ('+'); } R – R → ε 48 消除左递归时SDT的转换 (2) • 如果涉及属性值的计算，则有通用的解决方案 • 假设 – A → A1Y { A.a = g(A1.a, Y.y) } – A → X { A.a = f(X.x) } • 那么 – A → X { R.i = f(X.x) } R { A.a = R.s } – R → Y { R1.i = g(R.i, Y.y) } R1 { R.s = R1.s } – R → ε { R.s = R.i } 49 L属性的SDT • 除了通用的SDT实现技术，若基础文法是LL的， 则可以将L属性SDD转换成一个SDT，该SDT可以 在自顶向下的分析过程中实现 • 从L属性的SDD到SDT的转换 – 将每个语义规则看作是一个赋值语义动作 – 将赋值语义动作放到相应产生式A → X1 X2 … Xn的适 当位置 • 计算Xi继承属性的动作插入到产生式体中Xi的左边 • 计算产生式头A综合属性的动作在产生式的最右边 50 while语句的SDD和SDT • 产生式S → while (C) S1 – 为while语句生成中间代码 – 主要说明语句控制流中的标号生成 • while语句的含义 – 首先对C求值，若为真，则控制转向S1的开始处 – 若为假，则转向while语句的后续语句开始处 – S1结束时，要能够跳转到while语句的代码开始处 (此 例子中仅有部分考虑) 51 L属性的SDD的例子 • SDD • 继承属性 – next：语句结束后应该跳转到的标号 – true, false：C为真/假时应该跳转到的标号 • 综合属性code表示代码 52 转换为SDT • 语义动作 – (a) L1 = new( )和L2 = new( )：计算临时值 – (b) C.false = S.next; C.true = L2：计算C的继承属性 – (c) S1.next = L1：计算S1的继承属性 – (d) S.code = …：计算S的综合属型 • 根据放置语义动作的规则得到如下SDT – (b)在C之前，(c)在S1之前，(d)在最右端 – (a)可以放在最前面 53 L属性SDD的实现 • 使用递归下降的语法分析器 – 每个非终结符号对应一个函数 – 函数的参数接受继承属性，返回值包含了综合属性 • 在函数体中 – 首先选择适当的产生式 – 使用局部变量来保存属性 – 对于产生式体中的终结符号，读入符号并获取其 (经词 法分析得到的) 综合属性 – 对于非终结符号，使用适当的方式调用相应函数，并 记录返回值 54 递归下降实现L属性SDD的例子 55 C.false C.true S.next 边扫描边生成属性 (1) • 当属性值的体积很大，对其进行运算会效率很低 – code可能是一个上百K的串，对其进行并置会很低效 • 可逐步生成属性的各个部分，并增量式地添加到 最终的属性值中 (如数组或输出文件中) • 三个条件 – 存在一个主属性，且其为综合属性 – 在产生式中，主属性是通过产生式体中各非终结符号 的主属性连接而得到，同时还会连接一些其它元素 – 各个非终结符号的主属性的连接顺序与它们在产生式 体中的顺序相同 56 边扫描边生成属性 (2) • 基本思想 – 在适当的时候发出元素，并拼接到适当的地方 • 举例说明 – 假设扫描一个非终结符号对应的语法结构，调用其相 应的函数，并生成主属性 • S → while (C) S1 • { S.code = label || L1 || C.code || label || L2 || S1.code } – 如果各函数都把其主属性打印出来，则对while语句， 只需先打印label L1，再调用C (打印C的代码)，再打印 label L2，再调用S (打印S1的代码) – 需要在适当的时候打印label L1和label L2 57 边扫描边生成属性的例子 (1) • 新的SDT S → while ( { L1 = new(); L2 = new( ); C.false = S.next; C.true = L2; print(\"label\", L1); } C ) { S1.next = L1; print(\"label\", L2); } S1 • 前提是所有非终结符号的SDT规则都这么做 58 对照原SDT 边扫描边生成属性的例子 (2) 59 原来的 新的：边扫描边生成","libVersion":"0.3.2","langs":""}